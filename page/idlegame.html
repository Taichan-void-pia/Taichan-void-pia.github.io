<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>Idle â€” Prestige & Infinity (Step1-3 å®Ÿè£…)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui, "Segoe UI", Roboto, Helvetica, Arial; background:#071018;color:#fff;margin:0;padding:16px}
  h1{color:#7bf3a8;margin:0 0 8px 0}
  .errorBanner{background:#5b1010;color:#fff;padding:8px;border-radius:6px;margin-bottom:10px;display:none}
  .stats{background:rgba(255,255,255,0.03);padding:10px;border-radius:8px;margin-bottom:10px}
  #money{font-weight:700;color:#7bf3a8}
  #upgradeContainer{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:10px}
  .upgrade{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px}
  .meter{height:14px;background:rgba(255,255,255,0.04);border-radius:7px;overflow:hidden;margin:6px 0}
  .fill{height:100%;background:linear-gradient(90deg,#7bf3a8,#39d092);width:100%;transform-origin:left;will-change:transform}
  .btn{padding:6px;border-radius:6px;border:0;cursor:pointer}
  .btn-primary{background:#7bf3a8;color:#003628}
  .btn-small{background:rgba(255,255,255,0.03);color:#cfe8da;padding:4px 6px}
  .panel{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;margin-top:8px;display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .small{font-size:0.85em;color:#cfe8da}
  .speedControls{display:flex;gap:8px;align-items:center}
  .invisible{display:none}
  .shop{margin-top:10px;display:flex;gap:8px;flex-wrap:wrap}
  .shop .card{background:rgba(255,255,255,0.03);padding:8px;border-radius:6px}
  .col{display:flex;flex-direction:column;gap:6px}
  .skillsGrid{display:grid;grid-template-columns:repeat(10,1fr);gap:6px}
  .skillBtn{background:rgba(255,255,255,0.02);padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);cursor:pointer;font-size:0.8em}
  .skillBtn.purchased{box-shadow:0 0 8px rgba(123,243,168,0.6);border-color:#7bf3a8}
  .tune{display:flex;gap:8px;align-items:center}
</style>
</head>
<body>
  <div id="error" class="errorBanner"></div>

  <h1>ğŸ’° æ”¾ç½®ã‚²ãƒ¼ãƒ  â€” Prestige & Infinity (Step1-3)</h1>

  <div class="stats">
    æ‰€æŒé‡‘ï¼š<span id="money">0</span>ã€€
    ç§’ã‚ãŸã‚Šï¼š<span id="rate">0</span>
    <div class="small" id="formula">(è¨ˆç®—å¼)</div>
    <div style="margin-top:8px">
      ç„¡é™ãƒ¡ãƒ¼ã‚¿ãƒ¼ï¼š
      <div class="meter" style="display:inline-block;width:40%;margin-left:8px;vertical-align:middle">
        <div id="inftyFill" class="fill" style="transform:scaleX(0)"></div>
      </div>
      <span id="inftyPct" class="small" style="margin-left:8px">0%</span>
      <button id="gainInfinityBtn" class="btn btn-primary invisible" style="margin-left:10px">ç„¡é™ã‚’å¾—ã‚‹</button>
      <span class="small" style="margin-left:8px">ç„¡é™ãƒã‚¤ãƒ³ãƒˆ(IP): <span id="inftyPoints">0</span></span>
    </div>
  </div>

  <div class="panel">
    <div style="display:flex;gap:8px;align-items:center">
      <button id="prestigeBtn" class="btn btn-primary invisible">âœ¨ ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸</button>
      <button id="resetBtn" class="btn btn-small">ãƒªã‚»ãƒƒãƒˆï¼ˆå®Œå…¨ï¼‰</button>
      <label class="small" style="margin-left:8px">Auto-buy:
        <select id="autoQty">
          <option value="1">Ã—1</option><option value="10">Ã—10</option><option value="100">Ã—100</option><option value="max">Ã—Max</option>
        </select>
        <input id="autoToggle" type="checkbox" style="margin-left:6px" />ï¼ˆãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸1å›å¾Œã«æœ‰åŠ¹ï¼‰
      </label>
    </div>

    <div class="speedControls small" style="margin-left:auto">
      å€é€Ÿï¼š
      <select id="speedSelect">
        <option value="1">1Ã—</option>
        <option value="2">2Ã—</option>
        <option value="3">3Ã—</option>
      </select>
      <button id="speedDec" class="btn btn-small">-</button>
      <button id="speedInc" class="btn btn-small">+</button>
      <button id="pauseBtn" class="btn btn-small">ä¸€æ™‚åœæ­¢</button>
    </div>

    <div class="small" style="width:100%;margin-top:6px">ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸åˆå›æ¡ä»¶: 1e20ï¼ˆ2å›ç›®ä»¥é™ã¯å‰å›ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸æ™‚ã®ã‚¹ã‚³ã‚¢ã‚ˆã‚Šä¸Šï¼‰ â€” æ˜‡å¤©ã¯Lvä¸Šé™åˆ°é”ã§è¡¨ç¤ºãƒ»å®Ÿè¡Œå¯èƒ½</div>
  </div>

  <div id="upgradeContainer"></div>

  <div id="prestigeShop" class="shop"></div>

<script>
(function(){
  function showError(msg){
    const el = document.getElementById('error');
    el.style.display = 'block';
    el.textContent = 'ã‚¨ãƒ©ãƒ¼: ' + msg;
    console.error(msg);
  }

  try {
    // -------- BigNum (è»½é‡) ----------
    class BigNum {
      constructor(m=0,e=0){ this.m=m; this.e=e; this._normalize(); }
      static zero(){ return new BigNum(0,0); }
      static fromNumber(n){
        if (!isFinite(n) || n === 0) return BigNum.zero();
        const sign = n<0?-1:1;
        n = Math.abs(n);
        const exp = Math.floor(Math.log10(n));
        const mant = n / Math.pow(10, exp);
        return new BigNum(sign * mant, exp);
      }
      static fromObject(o){ if (!o || typeof o.m!=='number' || typeof o.e!=='number') return BigNum.zero(); return new BigNum(o.m, o.e); }
      static fromMantExp(m,e){ return new BigNum(m,e); }
      clone(){ return new BigNum(this.m, this.e); }
      _normalize(){
        if (!isFinite(this.m) || !isFinite(this.e) || this.m === 0){
          if (this.m === 0){ this.e = 0; this.m = 0; return; }
          if (!isFinite(this.m)) this.m = this.m > 0 ? 9.9999999999999 : -9.9999999999999;
        }
        if (this.m === 0){ this.e = 0; return; }
        let sign = this.m < 0 ? -1 : 1;
        let mabs = Math.abs(this.m);
        if (mabs === 0){ this.m = 0; this.e = 0; return; }
        const shift = Math.floor(Math.log10(mabs));
        if (isFinite(shift) && shift !== 0){ mabs = mabs / Math.pow(10, shift); this.e = this.e + shift; }
        if (mabs >= 10){ mabs = mabs / 10; this.e = this.e + 1; }
        this.m = sign * mabs;
      }
      toObject(){ return {m:this.m, e:this.e}; }
      toNumberSafe(){ if (!isFinite(this.m) || !isFinite(this.e)) return NaN; if (this.e > 15 || this.e < -15) return this.m>0?Infinity:-Infinity; return this.m * Math.pow(10, this.e); }
      toString(){ if (this.m === 0) return "0"; if (this.e <=12 && this.e >= -6){ const v=this.toNumberSafe(); if (isFinite(v)) return v.toLocaleString(undefined,{maximumFractionDigits:2}); } return this.m.toFixed(3) + "e" + this.e; }
      addInPlace(other){ if (typeof other === 'number') other = BigNum.fromNumber(other); if (!(other instanceof BigNum)) return; if (this.m === 0){ this.m = other.m; this.e = other.e; return; } if (other.m === 0) return; const diff = this.e - other.e; if (Math.abs(diff) > 15){ if (diff > 0) return; else { this.m = other.m; this.e = other.e; return; } } if (diff >= 0){ const scaled = other.m * Math.pow(10, -diff); this.m = this.m + scaled; } else { const scaled = this.m * Math.pow(10, diff); this.m = other.m + scaled; this.e = other.e; } this._normalize(); }
      subInPlace(other){ if (typeof other === 'number') other = BigNum.fromNumber(other); if (!(other instanceof BigNum)) return; other = new BigNum(-other.m, other.e); this.addInPlace(other); }
      mulInPlace(other){ if (typeof other === 'number'){ if (!isFinite(other) || other === 0){ this.m = 0; this.e = 0; return; } other = BigNum.fromNumber(other); } if (!(other instanceof BigNum)) return; if (this.m === 0 || other.m === 0){ this.m = 0; this.e = 0; return; } this.m = this.m * other.m; this.e = this.e + other.e; this._normalize(); }
      mulByNumber(n){ if (typeof n !== 'number') return; if (!isFinite(n) || n === 0){ this.m = 0; this.e = 0; return; } this.m = this.m * n; this._normalize(); }
      addNumber(n){ this.addInPlace(BigNum.fromNumber(n)); }
      gteNumber(n){ if (typeof n !== 'number') n = Number(n); if (!isFinite(n)) return false; if (n === 0) return this.m >= 0; const bn = BigNum.fromNumber(n); return this.gteBig(bn); }
      gteBig(b){ if (!(b instanceof BigNum)) b = BigNum.fromObject(b); if (this.m === 0 && b.m === 0) return true; if (this.e !== b.e) return this.e > b.e; return Math.abs(this.m) >= Math.abs(b.m); }
    }

    // --------------- constants & templates ---------------
    const INF_TARGET = BigNum.fromMantExp(1.8, 308); // 1.8e308
    // NOTE: INF_START used previously; for meter we start mapping from 1 (10^0) so user sees meter from 0
    const PROGRESS_CAP = 1e9;
    let costBaseMultVar = 1.15;

    const upgradesTemplate = [
      { name:"åå…¥ã‚¢ãƒƒãƒ—", baseRate:0.9, rate:0.9, mult:0, speedMult:1.18, baseCost:12, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"åŠ¹ç‡ã‚¢ãƒƒãƒ—", baseRate:0.6, rate:0.6, mult:0, speedMult:1.16, baseCost:40, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"è‡ªå‹•è²©å£²æ©Ÿ", baseRate:0.45, rate:0.45, mult:0, speedMult:1.14, baseCost:120, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"éŠ€è¡ŒæŠ•è³‡", baseRate:0.3, rate:0.3, mult:0, speedMult:1.12, baseCost:520, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"AIç”Ÿæˆå·¥å ´", baseRate:0.18, rate:0.18, mult:0, speedMult:1.10, baseCost:2200, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°", baseRate:0.14, rate:0.14, mult:0, speedMult:1.09, baseCost:12000, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"ç ”ç©¶æ‰€", baseRate:0.11, rate:0.11, mult:0, speedMult:1.085, baseCost:60000, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"æƒ‘æ˜Ÿé–‹ç™º", baseRate:0.08, rate:0.08, mult:0, speedMult:1.07, baseCost:250000, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"é‡å­ã‚µãƒ¼ãƒãƒ¼", baseRate:0.05, rate:0.05, mult:0, speedMult:1.055, baseCost:1200000, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"æ¬¡å…ƒã‚³ã‚¢", baseRate:0.02, rate:0.02, mult:0, speedMult:1.04, baseCost:6000000, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
    ];
    function cloneTemplate(){ return JSON.parse(JSON.stringify(upgradesTemplate)); }

    // --------------- state ---------------
    let money = BigNum.zero();
    let baseIncome = BigNum.fromNumber(1);
    let upgrades = cloneTemplate();
    let prestigePoints = 0; // integer points user can spend in shop
    let prestigeCount = 0;
    let prestigeMult = BigNum.fromNumber(1);
    let lastPrestigeScore = BigNum.zero();
    let infinityPoints = 0; // IP

    // global prestige bonuses (purchased with prestigePoints)
    const baseGlobalPrestige = { mAdd: 0, rMul: 1.0, costMul: 1.0 };
    const globalPrestige = Object.assign({}, baseGlobalPrestige);

    // --- Infinity / Generators (Step4) ---
    let generatorPoints = 0; // GP
    let generators = new Array(10).fill(0).map(()=>({count:0,progress:0}));
    const genBaseCost = [1,3,10,30,100,300,1000,3000,10000,30000];
    const genCostScale = 1.5;

    let speedMultiplier = 1.0; // 1..3
    let paused = false;

    let displayMoneyNum = 0;
    let prevProgress = [];
    let currProgress = [];
    const upgradeUI = [];

    // ----- softcap / prestige tuning parameters (èª¿æ•´å¯èƒ½) -----
    let softCapStartLog = 150; // softCap start at 10^150 (log10)
    let softCapStrength = 0.01; // small = gentler softcap; larger => stronger suppression
    // ------------------------------------------------------------

    // -------------------------
    // SkillNodes (50 nodes) -- define early to avoid reference-before-definition
    // -------------------------
    const SKILL_STORAGE_KEY = 'idle_skill_nodes_v1';
    // generate 50 nodes programmatically with diverse concrete effects
    const skillNodes = new Array(50).fill(0).map((_,i)=>{
      // vary effects among a set
      const effects = [
        {type:'mAdd', value:0.01},             // small additive to per-upgrade multiplier
        {type:'rMul', value:1.02},             // multiplicative to per-upgrade rate
        {type:'costMul', value:0.95},          // reduce cost
        {type:'baseIncome', value:1.05},       // multiply baseIncome
        {type:'genEff', value:1.10},           // multiply generator efficiency
      ];
      const eff = effects[i % effects.length];
      return {
        id: 'S' + (i+1),
        name: (i+1) + '. ' + (eff.type === 'mAdd' ? 'å¾®å¢—M' : eff.type === 'rMul' ? 'é€Ÿåº¦+' : eff.type === 'costMul' ? 'ã‚³ã‚¹ãƒˆæ¸›' : eff.type === 'baseIncome' ? 'åŸºç¤åå…¥+' : 'ã‚¸ã‚§ãƒåŠ¹ç‡+'),
        effect: eff,
        purchased: false,
        cost: Math.ceil(2 + Math.pow(1.18, i)) // modest scaling cost (prestigePoints)
      };
    });

    function loadSkillNodes(){
      try {
        const raw = localStorage.getItem(SKILL_STORAGE_KEY);
        if (!raw) return;
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr) || arr.length !== skillNodes.length) return;
        for (let i=0;i<skillNodes.length;i++){
          skillNodes[i].purchased = !!arr[i].purchased;
        }
      } catch(e){ console.warn('loadSkillNodes fail', e); }
    }
    function saveSkillNodes(){
      try {
        const arr = skillNodes.map(s => ({id:s.id, purchased: !!s.purchased}));
        localStorage.setItem(SKILL_STORAGE_KEY, JSON.stringify(arr));
      } catch(e){ console.warn('saveSkillNodes fail', e); }
    }
    function applySkillEffects(){
      // reset to base, then apply every purchased node exactly once
      Object.assign(globalPrestige, JSON.parse(JSON.stringify(baseGlobalPrestige)));
      // reset baseIncome to base 1 times current prestigeMult? We treat baseIncome as base number; we'll keep baseIncomeBase separately
      // For simplicity we'll store original base income baseline here:
      let baseIncomeBase = BigNum.fromNumber(1);
      baseIncome = baseIncomeBase.clone();

      // generatorPoints unaffected here; gen efficiency to be applied in relevant places (we store local multiplier)
      let genEffMultiplier = 1.0;

      for (let i=0;i<skillNodes.length;i++){
        const s = skillNodes[i];
        if (!s.purchased) continue;
        const eff = s.effect;
        switch(eff.type){
          case 'mAdd':
            globalPrestige.mAdd += eff.value;
            break;
          case 'rMul':
            globalPrestige.rMul *= eff.value;
            break;
          case 'costMul':
            globalPrestige.costMul *= eff.value;
            break;
          case 'baseIncome':
            baseIncome.mulByNumber(eff.value);
            break;
          case 'genEff':
            genEffMultiplier *= eff.value;
            break;
        }
      }
      // apply genEffMultiplier to generator behavior: store into a variable used by generator simulation
      window.__genEffMultiplier = genEffMultiplier;
    }

    function initSkillUI(){
      // insert skill UI into prestigeShop
      const shop = document.getElementById('prestigeShop');
      if (!shop) return;
      // create skill area container
      const existing = document.getElementById('skillArea');
      if (existing) existing.remove();
      const skillCard = document.createElement('div');
      skillCard.id = 'skillArea';
      skillCard.className = 'card col';
      skillCard.innerHTML = `<div><strong>ç„¡é™ã‚¹ã‚­ãƒ«ãƒ„ãƒªãƒ¼ï¼ˆSkill Nodesï¼‰</strong></div><div class="small">ã‚¿ãƒƒãƒ—ã—ã¦è©³ç´°ãƒ»è³¼å…¥ï¼ˆCost = prestige pointsï¼‰</div>`;
      const grid = document.createElement('div');
      grid.className = 'skillsGrid';
      skillNodes.forEach((s, idx) => {
        const btn = document.createElement('button');
        btn.className = 'skillBtn' + (s.purchased ? ' purchased' : '');
        btn.id = 'skillBtn_' + idx;
        btn.textContent = s.name + '\n(' + s.cost + ')';
        btn.addEventListener('click', ()=>{
          const detail = `ID:${s.id}\n${s.name}\nEffect: ${s.effect.type} Ã— ${s.effect.value}\nCost: ${s.cost} pts\nPurchased: ${s.purchased ? 'Yes' : 'No'}`;
          if (s.purchased){
            alert(detail);
            return;
          }
          if (confirm(detail + '\n\nè³¼å…¥ã—ã¾ã™ã‹ï¼Ÿï¼ˆãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ãƒã‚¤ãƒ³ãƒˆã‚’æ¶ˆè²»ï¼‰')){
            if (prestigePoints >= s.cost){
              prestigePoints -= s.cost;
              s.purchased = true;
              saveSkillNodes();
              applySkillEffects();
              saveGame();
              updateUI_throttled(true);
              initSkillUI();
              alert('è³¼å…¥ã—ã¾ã—ãŸ: ' + s.name);
            } else alert('ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ãƒã‚¤ãƒ³ãƒˆãŒè¶³ã‚Šã¾ã›ã‚“');
          }
        });
        grid.appendChild(btn);
      });
      skillCard.appendChild(grid);
      shop.appendChild(skillCard);
    }

    // helpers
    function fmtSmall(n){
      if (typeof n === 'number'){
        if (!isFinite(n)) return "Infinity";
        if (Math.abs(n) >= 1e15) return n.toExponential(2);
        if (Math.abs(n) >= 1e9) return (n/1e9).toFixed(2) + "B";
        if (Math.abs(n) >= 1e6) return (n/1e6).toFixed(2) + "M";
        return Math.floor(n).toLocaleString();
      }
      return String(n);
    }

    function bigNumLog10(bn){
      if (!(bn instanceof BigNum)) bn = BigNum.fromObject(bn);
      if (bn.m === 0) return -Infinity;
      return bn.e + Math.log10(Math.abs(bn.m));
    }

    function sanitizeUpgrades(list){
      for (let i=0;i<list.length;i++){
        const u = list[i];
        if (!u || typeof u !== 'object'){ list[i] = JSON.parse(JSON.stringify(upgradesTemplate[i])); continue; }
        if (typeof u.mult !== 'number') u.mult = 0;
        if (typeof u.rate !== 'number') u.rate = u.baseRate || upgradesTemplate[i].baseRate;
        if (typeof u.baseCost !== 'number') u.baseCost = upgradesTemplate[i].baseCost;
        if (typeof u.level !== 'number') u.level = 0;
        if (typeof u.progress !== 'number') u.progress = 0;
        if (!u.prestigeLevel || typeof u.prestigeLevel !== 'object') u.prestigeLevel = {mult:0,rate:0,cost:0};
        if (typeof u.ascendCount !== 'number') u.ascendCount = 0;
        if (typeof u.purchasePenalty !== 'number') u.purchasePenalty = 0;
        u._rateBN = u._rateBN ? BigNum.fromObject(u._rateBN) : BigNum.fromNumber(u.rate);
        u._multBN = u._multBN ? BigNum.fromObject(u._multBN) : BigNum.fromNumber(u.mult);
        u._baseCostBN = u._baseCostBN ? BigNum.fromObject(u._baseCostBN) : BigNum.fromNumber(u.baseCost);
      }
    }

    function getLevelCap(u){
      return 100 + (u.ascendCount || 0) * 10;
    }

    function getUpgradeCostBig(u, extraLevelOffset=0){
      const level = (u.level + extraLevelOffset);
      const factor = Math.pow(costBaseMultVar, Math.max(0, level));
      const c = u._baseCostBN.clone();
      c.mulByNumber(factor);
      const penalty = 1 + (u.purchasePenalty || 0);
      c.mulByNumber(penalty);
      c.mulByNumber(globalPrestige.costMul);
      return c;
    }

    // UI init
    function initUI(){
      const container = document.getElementById('upgradeContainer');
      container.innerHTML = '';
      upgrades.forEach((u,i)=>{
        const div = document.createElement('div');
        div.className = 'upgrade';
        const rateStr = (u._rateBN && u._rateBN.toNumberSafe && isFinite(u._rateBN.toNumberSafe())) ? u._rateBN.toNumberSafe().toFixed(2) : u._rateBN.toString();
        div.innerHTML = `
          <div style="display:flex;justify-content:space-between"><strong>${i+1}. ${u.name}</strong><div class="small">Lv <span id="lvl${i}">0</span>/<span id="cap${i}">100</span></div></div>
          <div class="small">æ˜‡å¤©å›æ•°: <span id="asc${i}">0</span></div>
          <div class="small">æ°¸ç¶š Lv(m/r/c): <span id="pLv${i}">0</span>/<span id="pLvR${i}">0</span>/<span id="pLvC${i}">0</span></div>
          <div class="small">ä¹—æ•°åˆè¨ˆ: <span id="mult${i}">+0.000</span></div>
          <div class="small">ãƒ¡ãƒ¼ã‚¿ãƒ¼é€Ÿåº¦: <span id="rate${i}">${rateStr}</span>/s</div>
          <div class="meter"><div id="fill${i}" class="fill" style="transform:scaleX(0)"></div></div>
          <div style="display:flex;gap:6px;flex-wrap:wrap;justify-content:center">
            <button id="buy1_${i}" class="btn btn-primary">è³¼å…¥ï¼ˆ<span id="cost${i}">0</span>ï¼‰</button>
            <button id="buy10_${i}" class="btn btn-small">Ã—10</button>
            <button id="buy100_${i}" class="btn btn-small">Ã—100</button>
            <button id="buyMax_${i}" class="btn btn-small">Ã—Max</button>
            <button id="asc_${i}" class="btn btn-small invisible">æ˜‡å¤©</button>
          </div>
        `;
        container.appendChild(div);
        upgradeUI[i] = {
          fillEl: document.getElementById('fill'+i),
          lvlEl: document.getElementById('lvl'+i),
          capEl: document.getElementById('cap'+i),
          costEl: document.getElementById('cost'+i),
          multEl: document.getElementById('mult'+i),
          rateEl: document.getElementById('rate'+i),
          ascEl: document.getElementById('asc'+i),
          pLvEl: document.getElementById('pLv'+i),
          pLvREl: document.getElementById('pLvR'+i),
          pLvCEl: document.getElementById('pLvC'+i),
          btn1: document.getElementById('buy1_'+i),
          btn10: document.getElementById('buy10_'+i),
          btn100: document.getElementById('buy100_'+i),
          btnMax: document.getElementById('buyMax_'+i),
          btnAsc: document.getElementById('asc_'+i),
        };
        upgradeUI[i].btn1.addEventListener('click', ()=> buyUpgrade(i,1,false));
        upgradeUI[i].btn10.addEventListener('click', ()=> buyUpgrade(i,10,false));
        upgradeUI[i].btn100.addEventListener('click', ()=> buyUpgrade(i,100,false));
        upgradeUI[i].btnMax.addEventListener('click', ()=> buyUpgrade(i,'max',false));
        upgradeUI[i].btnAsc.addEventListener('click', ()=> tryAscend(i));
      });

      prevProgress = new Array(upgrades.length).fill(0);
      currProgress = new Array(upgrades.length).fill(0);
      for (let i=0;i<upgrades.length;i++){ prevProgress[i] = upgrades[i].progress || 0; currProgress[i] = upgrades[i].progress || 0; }

      // skill UI must be rendered inside prestigeShop
      initSkillUI();
      renderPrestigeShop();
    }

    // ---- New: softCap & prestige boost functions ----
    function softCapMultiplierForScore(bn){
      // returns a JS Number multiplier <= 1 (BigNum multiplication of income will use this)
      const logVal = bigNumLog10(bn);
      if (!isFinite(logVal)) return 1;
      if (logVal <= softCapStartLog) return 1;
      const excess = logVal - softCapStartLog;
      const reduction = Math.pow(10, -softCapStrength * excess);
      if (!isFinite(reduction) || reduction <= 0) return 0;
      return Math.max(0, Math.min(1, reduction));
    }

    function prestigeBoostMultiplier(){
      // multiplier = exp(0.01 * sqrt(prestigePoints))
      const pp = Number(prestigePoints) || 0;
      if (pp <= 0) return 1;
      const exponent = 0.01 * Math.sqrt(pp);
      const safeExp = Math.min(exponent, 700);
      const mult = Math.exp(safeExp);
      if (!isFinite(mult)) return Number.MAX_VALUE;
      return mult;
    }

    // map Infinity progress from money >=1 to INF_TARGET (so meter starts from 0)
    function computeInfinityProgressPercent(bn){
      if (!(bn instanceof BigNum)) bn = BigNum.fromObject(bn);
      if (bn.m === 0) return 0;
      const logVal = bigNumLog10(bn);
      const logStart = 0; // 10^0 == 1 -> start counting from 1
      const logTarget = bigNumLog10(INF_TARGET);
      if (!isFinite(logVal)) return 0;
      if (logVal < logStart) return 0;
      if (logVal >= logTarget) return 100;
      const pct = (logVal - logStart) / (logTarget - logStart) * 100;
      return Math.max(0, Math.min(100, pct));
    }
    // -------------------------------------------------

    // throttled UI update
    let lastUI = 0;
    function updateUI_throttled(force){
      const now = performance.now();
      if (!force && now - lastUI < 100) return;
      lastUI = now;

      // compute total multiplier using BigNum fully
      let totalMultBN = BigNum.fromNumber(1);
      for (let i=0;i<upgrades.length;i++){
        const u = upgrades[i];
        const pMult = 0.02 * ((u.prestigeLevel && u.prestigeLevel.mult) || 0);
        const asc = 0.05 * (u.ascendCount || 0);
        const factorBN = BigNum.fromNumber(1);
        factorBN.addInPlace(u._multBN);
        factorBN.addNumber(pMult + asc + (globalPrestige.mAdd || 0));
        totalMultBN.mulInPlace(factorBN);
      }

      // baseIncome * totalMult
      const rateBN = baseIncome.clone();
      rateBN.mulInPlace(totalMultBN);

      // apply prestige boost (exponential) to final income
      const prestigeMultNum = prestigeBoostMultiplier();
      rateBN.mulByNumber(prestigeMultNum);

      // Decide whether to display as JS number or BigNum string
      // If total multiplier has grown large (> e16) -> show BigNum
      const totalLog = bigNumLog10(totalMultBN);
      const rateDisplayNum = rateBN.toNumberSafe();
      const rateEl = document.getElementById('rate');
      if ((isFinite(totalLog) && totalLog > 16) || (rateBN.e > 16) || !isFinite(rateDisplayNum)){
        rateEl.textContent = rateBN.toString();
      } else {
        rateEl.textContent = isFinite(rateDisplayNum) ? rateDisplayNum.toFixed(2) : rateBN.toString();
      }

      // show formula (human readable summary)
      let formulaParts = upgrades.map(u=>{
        const n = (u._multBN && u._multBN.toNumberSafe && isFinite(u._multBN.toNumberSafe())) ? u._multBN.toNumberSafe() : 0;
        const part = 1 + n + 0.02 * ((u.prestigeLevel&&u.prestigeLevel.mult)||0) + 0.05 * (u.ascendCount||0) + (globalPrestige.mAdd || 0);
        return '(1+' + part.toFixed(3) + ')';
      });
      document.getElementById('formula').textContent = 'åå…¥ = baseIncome Ã— ' + formulaParts.join(' Ã— ') + ' Ã— Prestige(exp)  ï¼ˆå€é€Ÿ: ' + speedMultiplier.toFixed(0) + (paused ? ' åœæ­¢ä¸­' : '') + 'ï¼‰';

      for (let i=0;i<upgrades.length;i++){
        const u = upgrades[i], ui = upgradeUI[i];
        if (!ui) continue;
        ui.lvlEl.textContent = u.level;
        ui.capEl.textContent = getLevelCap(u);
        ui.costEl.textContent = getUpgradeCostBig(u,0).toString();
        const multNum = u._multBN.toNumberSafe();
        ui.multEl.textContent = '+' + (isFinite(multNum) ? multNum.toFixed(3) : u._multBN.toString());
        const rateClone = u._rateBN.clone();
        rateClone.mulByNumber(globalPrestige.rMul || 1);
        const rateNum = rateClone.toNumberSafe();
        ui.rateEl.textContent = isFinite(rateNum) ? rateNum.toFixed(2) : rateClone.toString();
        ui.ascEl.textContent = u.ascendCount || 0;
        ui.pLvEl.textContent = (u.prestigeLevel && u.prestigeLevel.mult) || 0;
        ui.pLvREl.textContent = (u.prestigeLevel && u.prestigeLevel.rate) || 0;
        ui.pLvCEl.textContent = (u.prestigeLevel && u.prestigeLevel.cost) || 0;

        if (u.level >= getLevelCap(u)) ui.btnAsc.classList.remove('invisible'); else ui.btnAsc.classList.add('invisible');
        const canBuy = u.level < getLevelCap(u);
        ui.btn1.disabled = !canBuy;
        ui.btn10.disabled = !canBuy;
        ui.btn100.disabled = !canBuy;
        ui.btnMax.disabled = !canBuy;
      }

      const prestigeBtn = document.getElementById('prestigeBtn');
      let canPrestige = false;
      if (money.gteNumber(1e20)) {
        if (prestigeCount === 0) canPrestige = true;
        else {
          if (isMoneyGreaterThan(money, lastPrestigeScore)) canPrestige = true;
        }
      }
      if (canPrestige) prestigeBtn.classList.remove('invisible'); else prestigeBtn.classList.add('invisible');

      const inftyFill = document.getElementById('inftyFill');
      const inftyBtn = document.getElementById('gainInfinityBtn');
      const pct = computeInfinityProgressPercent(money);
      inftyFill.style.transform = 'scaleX(' + (pct/100) + ')';
      const pctEl = document.getElementById('inftyPct');
      if (pctEl) pctEl.textContent = pct.toFixed(6) + '%';
      if (money.gteBig(INF_TARGET)) inftyBtn.classList.remove('invisible'); else inftyBtn.classList.add('invisible');

      document.getElementById('inftyPoints').textContent = String(infinityPoints);

      renderPrestigeShop();
    }

    function isMoneyGreaterThan(a,b){
      if (!(a instanceof BigNum)) a = BigNum.fromObject(a);
      if (!(b instanceof BigNum)) b = BigNum.fromObject(b);
      if (a.e !== b.e) return a.e > b.e;
      return Math.abs(a.m) > Math.abs(b.m);
    }

    function costToBuyBig(u, n){
      if (n <= 0) return BigNum.zero();
      const remaining = Math.max(0, getLevelCap(u) - u.level);
      const want = Math.min(n, remaining);
      let total = BigNum.zero();
      for (let k=0;k<want;k++){
        const piece = getUpgradeCostBig(u, k);
        total.addInPlace(piece);
      }
      return total;
    }

    function getMultiplierIncrementBig(u){
      const base = 0.005 * Math.pow(1 + u.level, 0.38);
      const genFactor = 1 + ((window.__genEffMultiplier || 1) - 1) + (generatorPoints || 0) * 0.1;
      return BigNum.fromNumber(Math.min(base * genFactor, 1e12));
    }

    function buyUpgrade(idx, qty, silent){
      const u = upgrades[idx];
      if (u.level >= getLevelCap(u)){ if (!silent) alert('ã“ã®ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã¯æœ€å¤§Lvã§ã™ï¼ˆ' + getLevelCap(u) + 'ï¼‰'); return; }
      if (qty === 'max'){
        const remaining = getLevelCap(u) - u.level;
        let lo = 0, hi = 1;
        while (hi <= remaining && money.gteBig(costToBuyBig(u,hi))) hi *= 2;
        hi = Math.min(hi, remaining);
        while (lo + 1 < hi){
          const mid = Math.floor((lo + hi)/2);
          if (money.gteBig(costToBuyBig(u, mid))) lo = mid;
          else hi = mid;
        }
        if (lo > 0) doPurchase(u, idx, lo);
        else if (!silent) alert('ãŠé‡‘ãŒè¶³ã‚Šã¾ã›ã‚“');
        return;
      }
      const n = Number(qty) || 1;
      const allowed = Math.min(n, getLevelCap(u) - u.level);
      if (allowed <= 0){ if (!silent) alert('ã“ã‚Œä»¥ä¸Šè³¼å…¥ã§ãã¾ã›ã‚“ï¼ˆLvä¸Šé™ï¼‰'); return; }
      const costBN = costToBuyBig(u, allowed);
      if (money.gteBig(costBN)) doPurchase(u, idx, allowed);
      else if (!silent) alert('ãŠé‡‘ãŒè¶³ã‚Šã¾ã›ã‚“');
    }

    function doPurchase(u, idx, n){
      const costBN = costToBuyBig(u, n);
      money.subInPlace(costBN);
      const exponent = n * 0.12;
      const multiplier = Math.pow(Math.max(1, u.speedMult), exponent);
      u._rateBN.mulByNumber(multiplier);
      if (u._rateBN.e > 300) u._rateBN = BigNum.fromNumber(1e300);
      u.level += n;
      saveGame();
      updateUI_throttled(true);
    }

    function tryAscend(i){
      const u = upgrades[i];
      if (u.level < getLevelCap(u)){ alert('Lvä¸Šé™ã«åˆ°é”ã—ã¦ã‹ã‚‰æ˜‡å¤©å¯èƒ½ã§ã™ï¼ˆç¾åœ¨ Lv ' + u.level + ' / ' + getLevelCap(u) + 'ï¼‰'); return; }
      if (!confirm(u.name + ' ã‚’æ˜‡å¤©ã—ã¾ã™ã‹ï¼Ÿ LvãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã€æ°¸ç¶šãƒœãƒ¼ãƒŠã‚¹ãŒä»˜ä¸ã•ã‚Œã¾ã™ã€‚')) return;
      u.ascendCount = (u.ascendCount || 0) + 1;
      u.purchasePenalty = (u.purchasePenalty || 0) + 0.25;
      u.level = 0;
      u.progress = 0;
      u._rateBN = BigNum.fromNumber(u.baseRate || 1);
      u._multBN = BigNum.zero();
      saveGame();
      updateUI_throttled(true);
      alert(u.name + ' ã‚’æ˜‡å¤©ã—ã¾ã—ãŸï¼ˆæ˜‡å¤©å›æ•°: ' + u.ascendCount + 'ï¼‰\nè©²å½“ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®ã‚³ã‚¹ãƒˆãŒæ°¸ç¶šã§ +25% ã•ã‚Œã¾ã—ãŸã€‚');
    }

    // PRESTIGE logic
    function prestigePointsForScore(bn){
      if (!(bn instanceof BigNum)) bn = BigNum.fromObject(bn);
      if (bn.m === 0) return 0;
      const mantLog = Math.log10(Math.abs(bn.m));
      const log10val = bn.e + mantLog;
      const diff = log10val - 20;
      if (!isFinite(diff) || diff < 0) return 0;
      const points = Math.floor(diff) + 1;
      return points;
    }

    function doPrestige(force){
      let can = false;
      if (money.gteNumber(1e20)){
        if (prestigeCount === 0) can = true;
        else if (isMoneyGreaterThan(money, lastPrestigeScore)) can = true;
      }
      if (!force && !can){ alert('ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã›ã‚“'); return; }
      if (!force && !confirm('ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’å®Ÿè¡Œã—ã¾ã™ã‹ï¼Ÿï¼ˆå…¨ã¦ãƒªã‚»ãƒƒãƒˆã€ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ãƒã‚¤ãƒ³ãƒˆä»˜ä¸ã€‚ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ã¯å‰å›ã‚ˆã‚Šé«˜ã„ã‚¹ã‚³ã‚¢ã§ã®ã¿å†åº¦å¯èƒ½ï¼‰')) return;

      const pts = prestigePointsForScore(money);
      if (pts <= 0 && !force){ alert('ã‚¹ã‚³ã‚¢ãŒä¸ååˆ†ã§ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ãƒã‚¤ãƒ³ãƒˆã¯å¾—ã‚‰ã‚Œã¾ã›ã‚“'); return; }

      prestigePoints += pts;
      prestigeCount += 1;
      lastPrestigeScore = money.clone();

      money = BigNum.zero();
      baseIncome = BigNum.fromNumber(1);
      upgrades = cloneTemplate();
      sanitizeUpgrades(upgrades);
      saveGame();
      initUI();
      updateUI_throttled(true);
      alert('ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸å®Œäº†: prestigePoints +' + pts + '\nç¾åœ¨ã®ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ãƒã‚¤ãƒ³ãƒˆ: ' + prestigePoints);
    }

    // gain Infinity (IP)
    function gainInfinity(){
      if (!money.gteBig(INF_TARGET)){ alert('ã¾ã ç„¡é™ã«åˆ°é”ã—ã¦ã„ã¾ã›ã‚“'); return; }
      if (!confirm('ç„¡é™ã‚’å–å¾—ã—ã¾ã™ã‹ï¼Ÿï¼ˆGenerationã‚’å…¨ã¦ãƒªã‚»ãƒƒãƒˆã—ã€ç„¡é™ãƒã‚¤ãƒ³ãƒˆ (IP) +1ï¼‰')) return;
      infinityPoints += 1;

      // Reset Generation (but keep purchased skillNodes)
      money = BigNum.zero();
      baseIncome = BigNum.fromNumber(1);
      upgrades = cloneTemplate();
      sanitizeUpgrades(upgrades);
      prestigePoints = 0;
      prestigeCount = 0;
      prestigeMult = BigNum.fromNumber(1);
      lastPrestigeScore = BigNum.zero();

      costBaseMultVar = 1.15;
      Object.assign(globalPrestige, JSON.parse(JSON.stringify(baseGlobalPrestige)));

      speedMultiplier = 1.0;
      paused = false;
      displayMoneyNum = 0;
      prevProgress = new Array(upgrades.length).fill(0);
      currProgress = new Array(upgrades.length).fill(0);
      // keep skillNodes purchased state (per design)
      applySkillEffects();
      initUI();
      saveGame();
      updateUI_throttled(true);
      alert('ç„¡é™ã‚’å¾—ã¾ã—ãŸï¼ IP +1');
    }

    // RESET (full)
    function fullReset(){
      try { localStorage.removeItem('idle_all_big_save'); } catch(e){}
      try { localStorage.removeItem(SKILL_STORAGE_KEY); } catch(e){}
      // reset everything
      money = BigNum.zero();
      baseIncome = BigNum.fromNumber(1);
      upgrades = cloneTemplate();
      sanitizeUpgrades(upgrades);
      prestigePoints = 0;
      prestigeCount = 0;
      prestigeMult = BigNum.fromNumber(1);
      lastPrestigeScore = BigNum.zero();
      infinityPoints = 0;
      costBaseMultVar = 1.15;
      Object.assign(globalPrestige, JSON.parse(JSON.stringify(baseGlobalPrestige)));
      generatorPoints = 0;
      generators = new Array(10).fill(0).map(()=>({count:0,progress:0}));
      speedMultiplier = 1.0;
      paused = false;
      displayMoneyNum = 0;
      prevProgress = new Array(upgrades.length).fill(0);
      currProgress = new Array(upgrades.length).fill(0);
      // reset skill nodes
      skillNodes.forEach(s => s.purchased = false);
      saveSkillNodes();
      initUI();
      saveGame();
      updateUI_throttled(true);
    }

    // Save / Load
    function saveGame(){
      try {
        const save = {
          money: money.toObject(),
          baseIncome: baseIncome.toObject(),
          upgrades: upgrades.map(u => ({
            name:u.name, baseRate:u.baseRate,
            rateBN: u._rateBN.toObject(), multBN: u._multBN.toObject(), baseCostBN: u._baseCostBN.toObject(),
            baseCost: u.baseCost, level: u.level, progress: u.progress, prestigeLevel: u.prestigeLevel || {mult:0,rate:0,cost:0}, ascendCount: u.ascendCount || 0, purchasePenalty: u.purchasePenalty || 0
          })),
          prestigePoints,
          prestigeCount,
          prestigeMult: prestigeMult.toObject(),
          lastPrestigeScore: lastPrestigeScore.toObject(),
          infinityPoints,
          globalPrestige,
          costBaseMultVar,
          speedMultiplier,
          paused,
          generatorPoints,
          generators,
          softCapStartLog,
          softCapStrength
        };
        localStorage.setItem('idle_all_big_save', JSON.stringify(save));
        saveSkillNodes();
      } catch(e){ console.warn('save fail', e); try{ localStorage.removeItem('idle_all_big_save'); }catch(e){} }
    }

    function loadGame(){
      try {
        const raw = localStorage.getItem('idle_all_big_save');
        if (!raw) return;
        let data;
        try { data = JSON.parse(raw); } catch(parseErr){ console.warn('save parse failed, clearing', parseErr); localStorage.removeItem('idle_all_big_save'); return; }
        if (!data || typeof data !== 'object') return;

        if (data.money && typeof data.money.m === 'number') money = BigNum.fromObject(data.money);
        if (data.baseIncome && typeof data.baseIncome.m === 'number') baseIncome = BigNum.fromObject(data.baseIncome);

        if (Array.isArray(data.upgrades) && data.upgrades.length === upgradesTemplate.length){
          upgrades = data.upgrades.map((s,i) => {
            const t = JSON.parse(JSON.stringify(upgradesTemplate[i]));
            const merged = Object.assign(t, s);
            merged._rateBN = (s && s.rateBN) ? BigNum.fromObject(s.rateBN) : BigNum.fromNumber(merged.rate || merged.baseRate || 1);
            merged._multBN = (s && s.multBN) ? BigNum.fromObject(s.multBN) : BigNum.fromNumber(merged.mult || 0);
            merged._baseCostBN = (s && s.baseCostBN) ? BigNum.fromObject(s.baseCostBN) : BigNum.fromNumber(merged.baseCost || upgradesTemplate[i].baseCost);
            merged.level = Number.isFinite(+merged.level) ? Math.max(0, Math.floor(+merged.level)) : 0;
            merged.progress = Number.isFinite(+merged.progress) ? +merged.progress : 0;
            merged.prestigeLevel = merged.prestigeLevel || {mult:0,rate:0,cost:0};
            merged.ascendCount = Number.isFinite(+merged.ascendCount) ? +merged.ascendCount : 0;
            merged.purchasePenalty = Number.isFinite(+merged.purchasePenalty) ? +merged.purchasePenalty : 0;
            return merged;
          });
        }

        if (typeof data.prestigePoints === 'number') prestigePoints = data.prestigePoints;
        if (typeof data.prestigeCount === 'number') prestigeCount = data.prestigeCount;
        if (data.prestigeMult && typeof data.prestigeMult.m === 'number') prestigeMult = BigNum.fromObject(data.prestigeMult);
        if (data.lastPrestigeScore && typeof data.lastPrestigeScore.m === 'number') lastPrestigeScore = BigNum.fromObject(data.lastPrestigeScore);

        if (typeof data.infinityPoints === 'number') infinityPoints = data.infinityPoints;
        if (data.globalPrestige && typeof data.globalPrestige === 'object') Object.assign(globalPrestige, data.globalPrestige);
        if (typeof data.costBaseMultVar === 'number') costBaseMultVar = data.costBaseMultVar;
        if (typeof data.speedMultiplier === 'number') speedMultiplier = Math.max(1, Math.min(3, Math.round(data.speedMultiplier)));
        if (typeof data.paused === 'boolean') paused = !!data.paused;

        if (typeof data.generatorPoints === 'number') generatorPoints = data.generatorPoints;
        if (Array.isArray(data.generators) && data.generators.length === 10){
          generators = data.generators.map(g => ({
            count: Number.isFinite(+g.count) ? Math.max(0, Math.floor(+g.count)) : 0,
            progress: Number.isFinite(+g.progress) ? +g.progress : 0
          }));
        }

        if (typeof data.softCapStartLog === 'number') softCapStartLog = data.softCapStartLog;
        if (typeof data.softCapStrength === 'number') softCapStrength = data.softCapStrength;

        sanitizeUpgrades(upgrades);
      } catch(e){ console.warn('loadGame failed, clearing save', e); try{ localStorage.removeItem('idle_all_big_save'); }catch(e){} }
    }

    // simulation + render
    sanitizeUpgrades(upgrades);
    // load saves (upgrades + money)
    loadGame();
    // load skill nodes BEFORE applying effects / UI
    loadSkillNodes();
    // apply skill effects (skillNodes may modify baseIncome/globalPrestige)
    applySkillEffects();
    sanitizeUpgrades(upgrades);
    initUI();
    updateUI_throttled(true);

    const FIXED_DT = 0.05;
    let accumulator = 0;
    let lastTime = performance.now();

    function simulateGenerators(dt){
      const g1count = generators[0].count || 0;
      const g1PerSecPer = 0.001 * (window.__genEffMultiplier || 1);
      const gpGain = g1count * g1PerSecPer * dt;
      if (gpGain > 0) generatorPoints += gpGain;

      for (let tier = 1; tier < 10; tier++){
        const g = generators[tier];
        if (!g || g.count <= 0) continue;
        const perSec = 0.1 * g.count * (window.__genEffMultiplier || 1);
        g.progress += perSec * dt;
        if (g.progress >= 1){
          const inc = Math.floor(g.progress);
          g.progress -= inc;
          generators[tier-1].count += inc;
        }
      }
    }

    function simulateStep(dt){
      const s = speedMultiplier;
      for (let i=0;i<upgrades.length;i++){
        const u = upgrades[i];
        prevProgress[i] = currProgress[i];
        let progRate = NaN;
        try { progRate = (u._rateBN && typeof u._rateBN.toNumberSafe === 'function') ? u._rateBN.toNumberSafe() : NaN; } catch(e){ progRate = NaN; }
        if (!isFinite(progRate) || progRate <= 0) progRate = (u.baseRate || 0.01);
        progRate *= (globalPrestige.rMul || 1);
        let incProg = progRate * dt * 100 * s;
        if (!isFinite(incProg)) incProg = 0;
        currProgress[i] += incProg;
        if (currProgress[i] > PROGRESS_CAP) currProgress[i] = PROGRESS_CAP;
        if (currProgress[i] >= 100){
          let completed = Math.floor(currProgress[i] / 100);
          if (completed > 1000000) completed = 1000000;
          currProgress[i] -= completed * 100;
          const incBaseBN = getMultiplierIncrementBig(u);
          incBaseBN.mulByNumber(completed);
          u._multBN.addInPlace(incBaseBN);
          if (u._multBN.e > 300) u._multBN = BigNum.fromNumber(1e300);
        }
        u.progress = currProgress[i];
      }

      // compute total multiplier (BigNum), then compute addBN = baseIncome * totalMult * dt * s * softCap
      let totalMultBN = BigNum.fromNumber(1);
      for (let i=0;i<upgrades.length;i++){
        const u = upgrades[i];
        const pMult = 0.02 * ((u.prestigeLevel && u.prestigeLevel.mult) || 0);
        const asc = 0.05 * (u.ascendCount || 0);
        const factorBN = BigNum.fromNumber(1);
        factorBN.addInPlace(u._multBN);
        factorBN.addNumber(pMult + asc + (globalPrestige.mAdd || 0));
        totalMultBN.mulInPlace(factorBN);
      }

      const addBN = baseIncome.clone();
      addBN.mulInPlace(totalMultBN);

      // apply prestige boost to per-second income as specified (exponential smooth)
      const prestigeMultNum = prestigeBoostMultiplier();
      addBN.mulByNumber(prestigeMultNum);

      // apply softcap multiplier (based on total money)
      const softMult = softCapMultiplierForScore(money);
      addBN.mulByNumber(softMult);

      // time & speed factor
      addBN.mulByNumber(dt * s);

      money.addInPlace(addBN);

      // clamp money to INF_TARGET if it reaches or exceeds it to avoid overflow and accidental resets
      if (money.gteBig(INF_TARGET)) {
        money = INF_TARGET.clone();
      }

      simulateGenerators(dt);
    }

    function render(){
      const now = performance.now();
      let frameDelta = (now - lastTime) / 1000;
      if (!isFinite(frameDelta) || frameDelta <= 0) frameDelta = 0;
      lastTime = now;
      if (frameDelta > 0.5) frameDelta = 0.5;
      accumulator += frameDelta;
      if (accumulator > 0.5) accumulator = 0.5;

      if (!paused){
        while (accumulator >= FIXED_DT){
          simulateStep(FIXED_DT);
          accumulator -= FIXED_DT;
        }
      } else {
        accumulator = 0;
        for (let i=0;i<upgrades.length;i++) prevProgress[i] = currProgress[i];
      }

      const alpha = FIXED_DT === 0 ? 0 : (accumulator / FIXED_DT);

      // money display: if very large rely on BigNum.toString
      if (money.m === 0){
        displayMoneyNum += (0 - displayMoneyNum) * 0.12;
        document.getElementById('money').textContent = fmtSmall(displayMoneyNum);
      } else if (money.e <= 12){
        const v = money.toNumberSafe();
        if (isFinite(v)){
          displayMoneyNum += (v - displayMoneyNum) * 0.12;
          document.getElementById('money').textContent = fmtSmall(displayMoneyNum);
        } else {
          document.getElementById('money').textContent = money.toString();
        }
      } else {
        document.getElementById('money').textContent = money.toString();
      }

      for (let i=0;i<upgrades.length;i++){
        const interp = prevProgress[i] + (currProgress[i] - prevProgress[i]) * alpha;
        const w = Math.min(Math.max(interp, 0), 100);
        const el = upgradeUI[i] && upgradeUI[i].fillEl;
        if (el){
          const scale = Math.max(0, Math.min(1, w / 100));
          el.style.transform = 'scaleX(' + scale + ')';
        }
      }

      updateUI_throttled();
      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

    // wiring
    const prestigeBtn = document.getElementById('prestigeBtn');
    prestigeBtn.addEventListener('click', ()=> doPrestige(false));

    const inftyBtn = document.getElementById('gainInfinityBtn');
    if (inftyBtn) inftyBtn.addEventListener('click', gainInfinity);
    window.addEventListener('beforeunload', ()=> saveGame());

    const resetBtn = document.getElementById('resetBtn');
    resetBtn.addEventListener('click', ()=> {
      if (!confirm('æœ¬å½“ã«ã‚»ãƒ¼ãƒ–ã‚’å‰Šé™¤ã—ã¦ã‚²ãƒ¼ãƒ ã‚’å®Œå…¨ã«åˆæœŸåŒ–ã—ã¾ã™ã‹ï¼Ÿï¼ˆå…ƒã«æˆ»ã›ã¾ã›ã‚“ï¼‰')) return;
      fullReset();
      alert('ã‚²ãƒ¼ãƒ ã‚’å®Œå…¨ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚ã‚»ãƒ¼ãƒ–ã‚‚å‰Šé™¤ã•ã‚Œã¦ã„ã¾ã™ã€‚');
    });

    // auto-buy
    setInterval(function(){
      try {
        const autoOn = document.getElementById('autoToggle').checked && prestigeCount >= 1;
        if (!autoOn) return;
        const qty = document.getElementById('autoQty').value;
        const order = upgrades.map((u,i)=>({i,c:getUpgradeCostBig(u)})).sort((a,b)=>{
          if (a.c.e !== b.c.e) return a.c.e - b.c.e;
          return Math.abs(a.c.m) - Math.abs(b.c.m);
        });
        for (let k=0;k<order.length;k++){
          const entry = order[k];
          if (upgrades[entry.i].level >= getLevelCap(upgrades[entry.i])) continue;
          if (money.gteBig(entry.c)){
            buyUpgrade(entry.i, qty, true);
            break;
          }
        }
      } catch(e){ console.warn('auto-buy error', e); }
    }, 900);

    // speed UI
    const speedSelect = document.getElementById('speedSelect');
    const speedInc = document.getElementById('speedInc');
    const speedDec = document.getElementById('speedDec');
    const pauseBtn = document.getElementById('pauseBtn');
    function clampSpeed(v){ return Math.max(1, Math.min(3, Math.round(v))); }
    function updateSpeedUI(force){
      speedMultiplier = clampSpeed(speedMultiplier);
      speedSelect.value = String(speedMultiplier);
      pauseBtn.textContent = paused ? 'å†é–‹' : 'ä¸€æ™‚åœæ­¢';
      if (force) updateUI_throttled(true);
      saveGame();
    }
    speedSelect.addEventListener('change', ()=> { speedMultiplier = clampSpeed(Number(speedSelect.value)); updateSpeedUI(true); });
    speedInc.addEventListener('click', ()=> { speedMultiplier = clampSpeed(speedMultiplier + 1); updateSpeedUI(true); });
    speedDec.addEventListener('click', ()=> { speedMultiplier = clampSpeed(speedMultiplier - 1); updateSpeedUI(true); });
    pauseBtn.addEventListener('click', ()=> { paused = !paused; if (paused) accumulator = 0; updateSpeedUI(true); });
    window.addEventListener('keydown', (e) => {
      if (e.key === '['){ speedMultiplier = clampSpeed(speedMultiplier - 1); updateSpeedUI(true); e.preventDefault(); }
      else if (e.key === ']'){ speedMultiplier = clampSpeed(speedMultiplier + 1); updateSpeedUI(true); e.preventDefault(); }
      else if (e.code === 'Space'){ paused = !paused; if (paused) accumulator = 0; updateSpeedUI(true); e.preventDefault(); }
    });

    updateSpeedUI(true);

    // ===== Prestige + Infinity shop UI & logic =====
    function genCostForPurchase(tier, qty){
      const base = genBaseCost[tier];
      let total = 0;
      let cur = generators[tier].count || 0;
      for (let k=0;k<qty;k++){
        total += Math.ceil(base * Math.pow(genCostScale, cur + k));
      }
      return total;
    }

    function buyGenerator(tier, qty){
      qty = Number(qty) || 1;
      if (qty <= 0) return;
      const cost = genCostForPurchase(tier, qty);
      if (infinityPoints < cost){ alert('IPãŒè¶³ã‚Šã¾ã›ã‚“'); return; }
      infinityPoints -= cost;
      generators[tier].count += qty;
      saveGame();
      updateUI_throttled(true);
      alert(`G${tier+1} ã‚’ ${qty} å€‹è³¼å…¥ã—ã¾ã—ãŸï¼ˆIP -${cost}ï¼‰`);
    }

    function renderPrestigeShop(){
      const shop = document.getElementById('prestigeShop');
      if (!shop) return;
      // keep existing content, clear and re-add
      // note: skill area is handled in initSkillUI
      // but we also add tuning controls here
      const existing = shop.querySelector('.tuneArea');
      if (existing) existing.remove();
      const tune = document.createElement('div');
      tune.className = 'card tuneArea';
      tune.innerHTML = `<div><strong>Softcap ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°</strong></div>
        <div class="small tune">Start log10: <input id="softStart" type="number" style="width:80px" value="${softCapStartLog}"> Strength: <input id="softStr" type="number" step="0.001" style="width:80px" value="${softCapStrength}"> <button id="applySoft" class="btn btn-small">é©ç”¨</button></div>
        <div class="small">â€» softcapStart ã‚’ä¸Šã’ã‚‹ / strength ã‚’ä¸‹ã’ã‚‹ã¨ e150 ãªã©ã§ã®é ­æ‰“ã¡ã‚’ç·©å’Œã§ãã¾ã™ã€‚</div>`;
      shop.appendChild(tune);
      document.getElementById('softStart').addEventListener('change', (e)=> { softCapStartLog = Number(e.target.value) || softCapStartLog; saveGame(); updateUI_throttled(true); });
      document.getElementById('softStr').addEventListener('change', (e)=> { softCapStrength = Number(e.target.value) || softCapStrength; saveGame(); updateUI_throttled(true); });
      document.getElementById('applySoft').addEventListener('click', ()=> { saveGame(); updateUI_throttled(true); alert('softcap è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ'); });

      // info + generators area appended after skill area
      const info = document.createElement('div'); info.className='card';
      info.innerHTML = `<div><strong>ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ãƒã‚¤ãƒ³ãƒˆ: ${prestigePoints}</strong></div><div class="small">ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸å›æ•°: ${prestigeCount}</div>`;
      shop.appendChild(info);

      const prestigeItems = [
        { id:'m_add', title:'å…¨ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ m +0.01', cost:2, apply(){ globalPrestige.mAdd += 0.01; } },
        { id:'r_mul', title:'å…¨ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ r Ã—1.05', cost:3, apply(){ globalPrestige.rMul *= 1.05; } },
        { id:'cost_dec', title:'å…¨ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ ã‚³ã‚¹ãƒˆ -10%', cost:4, apply(){ globalPrestige.costMul *= 0.90; } },
        { id:'costGrowth_down', title:'ã‚³ã‚¹ãƒˆæˆé•·ç‡ã‚’-0.01', cost:6, apply(){ costBaseMultVar = Math.max(1.01, costBaseMultVar - 0.01); } },
      ];

      prestigeItems.forEach(item => {
        const card = document.createElement('div'); card.className='card';
        card.innerHTML = `<div><strong>${item.title}</strong></div><div class="small">Cost: ${item.cost} pts</div>`;
        const btn = document.createElement('button'); btn.className='btn btn-small'; btn.textContent='Buy';
        btn.addEventListener('click', ()=>{
          if (prestigePoints >= item.cost){
            prestigePoints -= item.cost;
            item.apply();
            saveGame();
            updateUI_throttled(true);
            alert('è³¼å…¥ã—ã¾ã—ãŸ: ' + item.title);
          } else alert('ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ãƒã‚¤ãƒ³ãƒˆãŒè¶³ã‚Šã¾ã›ã‚“');
        });
        card.appendChild(btn);
        shop.appendChild(card);
      });

      const ipCard = document.createElement('div'); ipCard.className='card';
      ipCard.innerHTML = `<div><strong>ç„¡é™ãƒã‚¤ãƒ³ãƒˆ(IP): ${infinityPoints}</strong></div><div class="small">GP: ${generatorPoints.toFixed(4)}</div>`;
      shop.appendChild(ipCard);

      const genContainer = document.createElement('div'); genContainer.className='card col';
      genContainer.innerHTML = `<div><strong>Generators (G1ã€œG10) â€” IPã§è³¼å…¥</strong></div><div class="small">G1ã¯GPã‚’ç”Ÿæˆã€‚G2..G10ã¯ä¸‹ä½ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’å¢—ã‚„ã—ã¾ã™ã€‚</div>`;
      for (let t=0;t<10;t++){
        const tier = t;
        const g = generators[tier];
        const base = genBaseCost[tier];
        const nextCost = Math.ceil(base * Math.pow(genCostScale, (g.count||0)));
        const line = document.createElement('div'); line.style.display='flex'; line.style.gap='8px'; line.style.alignItems='center';
        line.innerHTML = `<div style="flex:1"><strong>G${tier+1}</strong> â€” æ‰€æŒ: <span id="gcount${tier}">${g.count}</span></div><div class="small">æ¬¡: ${nextCost} IP</div>`;
        const buyBtn = document.createElement('button'); buyBtn.className='btn btn-small'; buyBtn.textContent='Buy Ã—1';
        buyBtn.addEventListener('click', ()=> buyGenerator(tier, 1));
        const buy5 = document.createElement('button'); buy5.className='btn btn-small'; buy5.textContent='Buy Ã—5';
        buy5.addEventListener('click', ()=> buyGenerator(tier, 5));
        line.appendChild(buyBtn); line.appendChild(buy5);
        genContainer.appendChild(line);
      }
      shop.appendChild(genContainer);
    }

    // Debug support (kept)
    (function() {
      const params = window.location.search;
      const match = params.match(/\?=(.+)/);
      if (!match) return;
      const command = match[1];
      console.log("DEBUG MODE:", command);
      const [key, value] = command.split(":");
      switch (key) {
        case "prestige":
          money = BigNum.fromNumber(1e21);
          updateUI_throttled(true);
          alert("ãƒ‡ãƒãƒƒã‚°: ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸æ¡ä»¶ã‚’æº€ãŸã—ã¾ã—ãŸ");
          break;
        case "infinity":
          money = BigNum.fromMantExp(1.8,308);
          updateUI_throttled(true);
          alert("ãƒ‡ãƒãƒƒã‚°: ç„¡é™æ¡ä»¶ã‚’æº€ãŸã—ã¾ã—ãŸ");
          break;
        case "ascend":
          upgrades.forEach(u => u.level = getLevelCap(u));
          updateUI_throttled(true);
          alert("ãƒ‡ãƒãƒƒã‚°: å…¨ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã‚’Lvä¸Šé™ã«ã—ã¾ã—ãŸ");
          break;
        case "money":
          money = BigNum.fromNumber(Number(value) || 1e10);
          updateUI_throttled(true);
          alert("ãƒ‡ãƒãƒƒã‚°: æ‰€æŒé‡‘ã‚’ " + value + " ã«è¨­å®šã—ã¾ã—ãŸ");
          break;
        case "addIP":
          infinityPoints += Number(value) || 1;
          updateUI_throttled(true);
          alert("ãƒ‡ãƒãƒƒã‚°: IP ã‚’è¿½åŠ ã—ã¾ã—ãŸ");
          break;
        case "addG1":
          generators[0].count += Number(value) || 1;
          updateUI_throttled(true);
          alert("ãƒ‡ãƒãƒƒã‚°: G1 ã‚’è¿½åŠ ã—ã¾ã—ãŸ");
          break;
        case "reset":
          if (confirm("æœ¬å½“ã«å…¨ã¦ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ")){
            fullReset();
            alert("ãƒ‡ãƒãƒƒã‚°: ã‚»ãƒ¼ãƒ–ã‚’å®Œå…¨ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ");
          }
          break;
        default:
          alert("ä¸æ˜ãªãƒ‡ãƒãƒƒã‚°ã‚³ãƒãƒ³ãƒ‰: " + command);
      }
    })();

  } catch(err){
    showError(err && err.message ? err.message : String(err));
  }
})();
</script>
</body>
</html>
