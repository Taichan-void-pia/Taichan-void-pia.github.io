<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>Idle â€” Prestige & Infinity (Step4 â†’ æ”¹è¨‚)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui, "Segoe UI", Roboto, Helvetica, Arial; background:#071018;color:#fff;margin:0;padding:16px}
  h1{color:#7bf3a8;margin:0 0 8px 0}
  .errorBanner{background:#5b1010;color:#fff;padding:8px;border-radius:6px;margin-bottom:10px;display:none}
  .stats{background:rgba(255,255,255,0.03);padding:10px;border-radius:8px;margin-bottom:10px}
  #money{font-weight:700;color:#7bf3a8}
  #upgradeContainer{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:10px}
  .upgrade{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px}
  .meter{height:14px;background:rgba(255,255,255,0.04);border-radius:7px;overflow:hidden;margin:6px 0}
  .fill{height:100%;background:linear-gradient(90deg,#7bf3a8,#39d092);width:100%;transform-origin:left;will-change:transform}
  .btn{padding:6px;border-radius:6px;border:0;cursor:pointer}
  .btn-primary{background:#7bf3a8;color:#003628}
  .btn-small{background:rgba(255,255,255,0.03);color:#cfe8da;padding:4px 6px}
  .panel{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;margin-top:8px;display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .small{font-size:0.85em;color:#cfe8da}
  .speedControls{display:flex;gap:8px;align-items:center}
  .invisible{display:none}
  .shop{margin-top:10px;display:flex;gap:8px;flex-wrap:wrap}
  .shop .card{background:rgba(255,255,255,0.03);padding:8px;border-radius:6px}
  .col{display:flex;flex-direction:column;gap:6px}
  .skillsGrid{display:grid;grid-template-columns:repeat(10,1fr);gap:6px;margin-top:8px}
  .skillBtn{background:rgba(255,255,255,0.02);padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);cursor:pointer;font-size:0.8em;white-space:pre-line}
  .skillBtn.purchased{box-shadow:0 0 8px rgba(123,243,168,0.6);border-color:#7bf3a8}
  .tabs{display:flex;gap:8px;margin:8px 0}
  .tabBtn{padding:6px 10px;border-radius:6px;background:rgba(255,255,255,0.03);cursor:pointer}
  .tabBtn.active{background:#7bf3a8;color:#003628}
  .cardRow{display:flex;gap:8px;flex-wrap:wrap}
</style>
</head>
<body>
  <div id="error" class="errorBanner"></div>
  <h1>ğŸ’° æ”¾ç½®ã‚²ãƒ¼ãƒ  â€” Prestige & Infinity (Step4 æ”¹è¨‚)</h1>

  <div class="stats">
    æ‰€æŒé‡‘ï¼š<span id="money">0</span>ã€€
    ç§’ã‚ãŸã‚Šï¼š<span id="rate">0</span>
    <div class="small" id="formula">(è¨ˆç®—å¼)</div>
    <div style="margin-top:8px">
      ç„¡é™ãƒ¡ãƒ¼ã‚¿ãƒ¼ï¼š
      <div class="meter" style="display:inline-block;width:40%;margin-left:8px;vertical-align:middle">
        <div id="inftyFill" class="fill" style="transform:scaleX(0)"></div>
      </div>
      <span id="inftyPct" class="small" style="margin-left:8px">0%</span>
      <button id="gainInfinityBtn" class="btn btn-primary invisible" style="margin-left:10px">ç„¡é™ã‚’å¾—ã‚‹</button>
      <span class="small" style="margin-left:8px">ç„¡é™ãƒã‚¤ãƒ³ãƒˆ(IP): <span id="inftyPoints">0</span></span>
      <span class="small" style="margin-left:8px">GDP: <span id="gdpDisp">0</span></span>
    </div>
  </div>

  <div class="panel">
    <div style="display:flex;gap:8px;align-items:center">
      <button id="prestigeBtn" class="btn btn-primary invisible">âœ¨ ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸</button>
      <button id="resetBtn" class="btn btn-small">ãƒªã‚»ãƒƒãƒˆï¼ˆå®Œå…¨ï¼‰</button>
      <label class="small" style="margin-left:8px">Auto-buy:
        <select id="autoQty">
          <option value="1">Ã—1</option><option value="10">Ã—10</option><option value="100">Ã—100</option><option value="max">Ã—Max</option>
        </select>
        <input id="autoToggle" type="checkbox" style="margin-left:6px" />ï¼ˆãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸1å›å¾Œã«æœ‰åŠ¹ï¼‰
      </label>
    </div>

    <div class="speedControls small" style="margin-left:auto">
      å€é€Ÿï¼š
      <select id="speedSelect">
        <option value="1">1Ã—</option>
        <option value="2">2Ã—</option>
        <option value="3">3Ã—</option>
      </select>
      <button id="speedDec" class="btn btn-small">-</button>
      <button id="speedInc" class="btn btn-small">+</button>
      <button id="pauseBtn" class="btn btn-small">ä¸€æ™‚åœæ­¢</button>
    </div>
  </div>

  <div class="tabs" role="tablist">
    <button id="tabGen" class="tabBtn active">Generation</button>
    <button id="tabInf" class="tabBtn">Infinity</button>
  </div>

  <div id="upgradeContainer"></div>
  <div id="prestigeShop" class="shop" style="display:none"></div>

<script>
(function(){
  function showError(msg){
    const el = document.getElementById('error');
    el.style.display = 'block';
    el.textContent = 'ã‚¨ãƒ©ãƒ¼: ' + msg;
    console.error(msg);
  }

  try {
    // ---------- BigNum ----------
    class BigNum {
      constructor(m=0,e=0){ this.m=m; this.e=e; this._normalize(); }
      static zero(){ return new BigNum(0,0); }
      static fromNumber(n){
        if (!isFinite(n) || n === 0) return BigNum.zero();
        const sign = n<0?-1:1;
        n = Math.abs(n);
        const exp = Math.floor(Math.log10(n));
        const mant = n / Math.pow(10, exp);
        return new BigNum(sign * mant, exp);
      }
      static fromObject(o){ if (!o || typeof o.m!=='number' || typeof o.e!=='number') return BigNum.zero(); return new BigNum(o.m, o.e); }
      static fromMantExp(m,e){ return new BigNum(m,e); }
      clone(){ return new BigNum(this.m, this.e); }
      _normalize(){
        if (!isFinite(this.m) || !isFinite(this.e) || this.m === 0){
          if (this.m === 0){ this.e = 0; this.m = 0; return; }
          if (!isFinite(this.m)) this.m = this.m > 0 ? 9.9999999999999 : -9.9999999999999;
        }
        if (this.m === 0){ this.e = 0; return; }
        let sign = this.m < 0 ? -1 : 1;
        let mabs = Math.abs(this.m);
        if (mabs === 0){ this.m = 0; this.e = 0; return; }
        const shift = Math.floor(Math.log10(mabs));
        if (isFinite(shift) && shift !== 0){ mabs = mabs / Math.pow(10, shift); this.e = this.e + shift; }
        if (mabs >= 10){ mabs = mabs / 10; this.e = this.e + 1; }
        this.m = sign * mabs;
      }
      toObject(){ return {m:this.m, e:this.e}; }
      toNumberSafe(){ if (!isFinite(this.m) || !isFinite(this.e)) return NaN; if (this.e > 15 || this.e < -15) return this.m>0?Infinity:-Infinity; return this.m * Math.pow(10, this.e); }
      toString(){ if (this.m === 0) return "0"; if (this.e <=12 && this.e >= -6){ const v=this.toNumberSafe(); if (isFinite(v)) return v.toLocaleString(undefined,{maximumFractionDigits:2}); } return this.m.toFixed(3) + "e" + this.e; }
      addInPlace(other){ if (typeof other === 'number') other = BigNum.fromNumber(other); if (!(other instanceof BigNum)) return; if (this.m === 0){ this.m = other.m; this.e = other.e; return; } if (other.m === 0) return; const diff = this.e - other.e; if (Math.abs(diff) > 15){ if (diff > 0) return; else { this.m = other.m; this.e = other.e; return; } } if (diff >= 0){ const scaled = other.m * Math.pow(10, -diff); this.m = this.m + scaled; } else { const scaled = this.m * Math.pow(10, diff); this.m = other.m + scaled; this.e = other.e; } this._normalize(); }
      subInPlace(other){ if (typeof other === 'number') other = BigNum.fromNumber(other); if (!(other instanceof BigNum)) return; other = new BigNum(-other.m, other.e); this.addInPlace(other); }
      mulInPlace(other){ if (typeof other === 'number'){ if (!isFinite(other) || other === 0){ this.m = 0; this.e = 0; return; } other = BigNum.fromNumber(other); } if (!(other instanceof BigNum)) return; if (this.m === 0 || other.m === 0){ this.m = 0; this.e = 0; return; } this.m = this.m * other.m; this.e = this.e + other.e; this._normalize(); }
      mulByNumber(n){ if (typeof n !== 'number') return; if (!isFinite(n) || n === 0){ this.m = 0; this.e = 0; return; } this.m = this.m * n; this._normalize(); }
      addNumber(n){ this.addInPlace(BigNum.fromNumber(n)); }
      gteNumber(n){ if (typeof n !== 'number') n = Number(n); if (!isFinite(n)) return false; if (n === 0) return this.m >= 0; const bn = BigNum.fromNumber(n); return this.gteBig(bn); }
      gteBig(b){ if (!(b instanceof BigNum)) b = BigNum.fromObject(b); if (this.m === 0 && b.m === 0) return true; if (this.e !== b.e) return this.e > b.e; return Math.abs(this.m) >= Math.abs(b.m); }
      ltBig(b){ if (!(b instanceof BigNum)) b = BigNum.fromObject(b); if (this.m === 0 && b.m !== 0) return true; if (this.e !== b.e) return this.e < b.e; return Math.abs(this.m) < Math.abs(b.m); }
    }

    // --------------- constants & templates ---------------
    const INF_TARGET = BigNum.fromMantExp(1.8, 308); // 1.8e308
    const PROGRESS_CAP = 1e9;
    let costBaseMultVar = 1.15;

    const upgradesTemplate = [
      { name:"åå…¥ã‚¢ãƒƒãƒ—", baseRate:0.9, rate:0.9, mult:0, speedMult:1.18, baseCost:12, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"åŠ¹ç‡ã‚¢ãƒƒãƒ—", baseRate:0.6, rate:0.6, mult:0, speedMult:1.16, baseCost:40, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"è‡ªå‹•è²©å£²æ©Ÿ", baseRate:0.45, rate:0.45, mult:0, speedMult:1.14, baseCost:120, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"éŠ€è¡ŒæŠ•è³‡", baseRate:0.3, rate:0.3, mult:0, speedMult:1.12, baseCost:520, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"AIç”Ÿæˆå·¥å ´", baseRate:0.18, rate:0.18, mult:0, speedMult:1.10, baseCost:2200, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°", baseRate:0.14, rate:0.14, mult:0, speedMult:1.09, baseCost:12000, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"ç ”ç©¶æ‰€", baseRate:0.11, rate:0.11, mult:0, speedMult:1.085, baseCost:60000, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"æƒ‘æ˜Ÿé–‹ç™º", baseRate:0.08, rate:0.08, mult:0, speedMult:1.07, baseCost:250000, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"é‡å­ã‚µãƒ¼ãƒãƒ¼", baseRate:0.05, rate:0.05, mult:0, speedMult:1.055, baseCost:1200000, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"æ¬¡å…ƒã‚³ã‚¢", baseRate:0.02, rate:0.02, mult:0, speedMult:1.04, baseCost:6000000, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
    ];
    function cloneTemplate(){ return JSON.parse(JSON.stringify(upgradesTemplate)); }

    // --------------- state ---------------
    let money = BigNum.zero();
    let baseIncome = BigNum.fromNumber(1);
    let upgrades = cloneTemplate();
    let prestigePoints = 0;
    let prestigeCount = 0;
    let prestigeMult = BigNum.fromNumber(1);
    let lastPrestigeScore = BigNum.zero();
    // Infinity Points as BigNum (use IP for skill purchases / generators / mines)
    let infinityPoints = BigNum.zero();

    // global prestige bonuses
    const baseGlobalPrestige = { mAdd: 0, rMul: 1.0, costMul: 1.0 };
    const globalPrestige = Object.assign({}, baseGlobalPrestige);

    // Infinity / Generators
    let generatorPoints = 0; // number GP
    // generators is dynamic (infinite tiers). initial tiers created.
    let generators = [];
    const INITIAL_TIERS = 8;
    const genBaseCostBase = 2; // base multiplier for cost formula
    let genCostScale = 2.5; // steeper growth per your request
    // gp penalty base (affects generator efficiency). Can be reduced by skill nodes.
    let gpPenaltyFactorBase = 0.08;
    let gpPenaltyReductionFromSkills = 0;

    // Mines + GDP
    let minesCount = 0;
    let gdp = BigNum.zero(); // Golden Particles
    const gdpPerMinePerSec = 0.5; // per mine per sec
    // cost scale for mines (in IP)
    const minesBaseIP = 5;
    const minesIPScale = 2.0;

    // SkillNodes (50 nodes purchasable with IP sequentially)
    const SKILL_STORAGE_KEY = 'idle_skill_nodes_v2';
    const SKILL_COUNT = 50;
    const skillNodes = new Array(SKILL_COUNT).fill(0).map((_,i)=>{
      // round costs (IP) increase
      const cost = Math.ceil(1 + Math.pow(1.2, i)); // modest growth; tuneable
      const types = ['ipMultAdd','genEff','gpPenaltyReduce','finalInc','mineBonus'];
      const t = types[i % types.length];
      let effect;
      switch(t){
        case 'ipMultAdd': effect = {type:'ipMultAdd', value:2}; break;
        case 'genEff': effect = {type:'genEff', value:1.10}; break;
        case 'gpPenaltyReduce': effect = {type:'gpPenaltyReduce', value:0.01}; break;
        case 'finalInc': effect = {type:'finalInc', value:1.05}; break;
        case 'mineBonus': effect = {type:'mineBonus', value:0.05}; break;
      }
      return { id:'S'+(i+1), name:'Skill '+(i+1), effect, purchased:false, cost };
    });

    // Infinity Challenges (9)
    const INF_CHALLENGE_STORAGE = 'idle_inf_challenges_v2';
    const infinityChallenges = new Array(9).fill(0).map((_,i)=>{
      return {
        id: 'C' + (i+1),
        name: 'Challenge ' + (i+1),
        desc: 'åˆ¶ç´„ ' + (i+1),
        reqIP: 0,
        active: false,
        completed: false,
        // reward objects simplified: some will give IP multiplier indirectly (we use completed count)
        reward: {type:'misc', value:1}
      };
    });

    // UI / simulation helpers
    function fmtSmall(n){
      if (n instanceof BigNum) return n.toString();
      if (typeof n === 'number'){
        if (!isFinite(n)) return "Infinity";
        if (Math.abs(n) >= 1e15) return n.toExponential(2);
        if (Math.abs(n) >= 1e9) return (n/1e9).toFixed(2) + "B";
        if (Math.abs(n) >= 1e6) return (n/1e6).toFixed(2) + "M";
        return Math.floor(n).toLocaleString();
      }
      return String(n);
    }
    function bigNumLog10(bn){
      if (!(bn instanceof BigNum)) bn = BigNum.fromObject(bn);
      if (bn.m === 0) return -Infinity;
      return bn.e + Math.log10(Math.abs(bn.m));
    }

    // sanitize upgrades
    function sanitizeUpgrades(list){
      for (let i=0;i<list.length;i++){
        const u = list[i];
        if (!u || typeof u !== 'object'){ list[i] = JSON.parse(JSON.stringify(upgradesTemplate[i])); continue; }
        if (typeof u.mult !== 'number') u.mult = 0;
        if (typeof u.rate !== 'number') u.rate = u.baseRate || upgradesTemplate[i].baseRate;
        if (typeof u.baseCost !== 'number') u.baseCost = upgradesTemplate[i].baseCost;
        if (typeof u.level !== 'number') u.level = 0;
        if (typeof u.progress !== 'number') u.progress = 0;
        if (!u.prestigeLevel || typeof u.prestigeLevel !== 'object') u.prestigeLevel = {mult:0,rate:0,cost:0};
        if (typeof u.ascendCount !== 'number') u.ascendCount = 0;
        if (typeof u.purchasePenalty !== 'number') u.purchasePenalty = 0;
        u._rateBN = u._rateBN ? BigNum.fromObject(u._rateBN) : BigNum.fromNumber(u.rate);
        u._multBN = u._multBN ? BigNum.fromObject(u._multBN) : BigNum.fromNumber(u.mult);
        u._baseCostBN = u._baseCostBN ? BigNum.fromObject(u._baseCostBN) : BigNum.fromNumber(u.baseCost);
      }
    }

    function getLevelCap(u){ return 100 + (u.ascendCount || 0) * 10; }
    function getUpgradeCostBig(u, extraLevelOffset=0){
      const level = (u.level + extraLevelOffset);
      const factor = Math.pow(costBaseMultVar, Math.max(0, level));
      const c = u._baseCostBN.clone();
      c.mulByNumber(factor);
      const penalty = 1 + (u.purchasePenalty || 0);
      c.mulByNumber(penalty);
      c.mulByNumber(globalPrestige.costMul || 1);
      return c;
    }

    // initialize generators dynamic list
    function ensureInitialGenerators(){
      while (generators.length < INITIAL_TIERS){
        generators.push({count:0, progress:0});
      }
    }
    ensureInitialGenerators();

    // GP penalty factor applied to generator efficiency
    function computeGPPenaltyFactor(){
      // penalty = 1 / (1 + GP * (gpPenaltyFactorBase - reductions))
      const base = Math.max(0.001, gpPenaltyFactorBase - gpPenaltyReductionFromSkills);
      return 1 / (1 + generatorPoints * base);
    }

    // save/load skill nodes
    function loadSkillNodes(){
      try {
        const raw = localStorage.getItem(SKILL_STORAGE_KEY);
        if (!raw) return;
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr) || arr.length !== skillNodes.length) return;
        for (let i=0;i<skillNodes.length;i++) skillNodes[i].purchased = !!arr[i].purchased;
      } catch(e){ console.warn('loadSkillNodes fail', e); }
    }
    function saveSkillNodes(){
      try {
        const arr = skillNodes.map(s => ({id:s.id, purchased: !!s.purchased}));
        localStorage.setItem(SKILL_STORAGE_KEY, JSON.stringify(arr));
      } catch(e){ console.warn('saveSkillNodes fail', e); }
    }

    // apply skill effects (affects gp penalty reduction, gen eff, mine bonus)
    function applySkillEffects(){
      gpPenaltyReductionFromSkills = 0;
      let extraGenEff = 1.0;
      skillNodes.forEach(s=>{
        if (!s.purchased) return;
        const eff = s.effect;
        if (eff.type === 'genEff') extraGenEff *= eff.value;
        if (eff.type === 'gpPenaltyReduce') gpPenaltyReductionFromSkills += eff.value;
      });
      window.__genEffBaseFromSkills = extraGenEff;
      // clamp
      gpPenaltyReductionFromSkills = Math.min(0.6, gpPenaltyReductionFromSkills);
    }

    // UI init
    const upgradeUI = [];
    function initUI(){
      const container = document.getElementById('upgradeContainer');
      container.innerHTML = '';
      upgrades.forEach((u,i)=>{
        const div = document.createElement('div');
        div.className = 'upgrade';
        const rateStr = (u._rateBN && u._rateBN.toNumberSafe && isFinite(u._rateBN.toNumberSafe())) ? u._rateBN.toNumberSafe().toFixed(2) : u._rateBN.toString();
        div.innerHTML = `
          <div style="display:flex;justify-content:space-between"><strong>${i+1}. ${u.name}</strong><div class="small">Lv <span id="lvl${i}">0</span>/<span id="cap${i}">100</span></div></div>
          <div class="small">æ˜‡å¤©å›æ•°: <span id="asc${i}">0</span></div>
          <div class="small">æ°¸ç¶š Lv(m/r/c): <span id="pLv${i}">0</span>/<span id="pLvR${i}">0</span>/<span id="pLvC${i}">0</span></div>
          <div class="small">ä¹—æ•°åˆè¨ˆ: <span id="mult${i}">+0.000</span></div>
          <div class="small">ãƒ¡ãƒ¼ã‚¿ãƒ¼é€Ÿåº¦: <span id="rate${i}">${rateStr}</span>/s</div>
          <div class="meter"><div id="fill${i}" class="fill" style="transform:scaleX(0)"></div></div>
          <div style="display:flex;gap:6px;flex-wrap:wrap;justify-content:center">
            <button id="buy1_${i}" class="btn btn-primary">è³¼å…¥ï¼ˆ<span id="cost${i}">0</span>ï¼‰</button>
            <button id="buy10_${i}" class="btn btn-small">Ã—10</button>
            <button id="buy100_${i}" class="btn btn-small">Ã—100</button>
            <button id="buyMax_${i}" class="btn btn-small">Ã—Max</button>
            <button id="asc_${i}" class="btn btn-small invisible">æ˜‡å¤©</button>
          </div>
        `;
        container.appendChild(div);
        upgradeUI[i] = {
          fillEl: document.getElementById('fill'+i),
          lvlEl: document.getElementById('lvl'+i),
          capEl: document.getElementById('cap'+i),
          costEl: document.getElementById('cost'+i),
          multEl: document.getElementById('mult'+i),
          rateEl: document.getElementById('rate'+i),
          ascEl: document.getElementById('asc'+i),
          pLvEl: document.getElementById('pLv'+i),
          pLvREl: document.getElementById('pLvR'+i),
          pLvCEl: document.getElementById('pLvC'+i),
          btn1: document.getElementById('buy1_'+i),
          btn10: document.getElementById('buy10_'+i),
          btn100: document.getElementById('buy100_'+i),
          btnMax: document.getElementById('buyMax_'+i),
          btnAsc: document.getElementById('asc_'+i),
        };
        upgradeUI[i].btn1.addEventListener('click', ()=> buyUpgrade(i,1,false));
        upgradeUI[i].btn10.addEventListener('click', ()=> buyUpgrade(i,10,false));
        upgradeUI[i].btn100.addEventListener('click', ()=> buyUpgrade(i,100,false));
        upgradeUI[i].btnMax.addEventListener('click', ()=> buyUpgrade(i,'max',false));
        upgradeUI[i].btnAsc.addEventListener('click', ()=> tryAscend(i));
      });

      updateUI_throttled(true);
    }

    // softcap only internal â€” UI removed per request
    const softCapStartLog = 150;
    const softCapStrength = 0.01;
    function softCapMultiplierForScore(bn){
      const logVal = bigNumLog10(bn);
      if (!isFinite(logVal)) return 1;
      if (logVal <= softCapStartLog) return 1;
      const excess = logVal - softCapStartLog;
      const reduction = Math.pow(10, -softCapStrength * excess);
      if (!isFinite(reduction) || reduction <= 0) return 0;
      return Math.max(0, Math.min(1, reduction));
    }

    function prestigeBoostMultiplier(){
      const pp = Number(prestigePoints) || 0;
      if (pp <= 0) return 1;
      const exponent = 0.01 * Math.sqrt(pp);
      const safeExp = Math.min(exponent, 700);
      const mult = Math.exp(safeExp);
      if (!isFinite(mult)) return Number.MAX_VALUE;
      return mult;
    }

    // IP multiplier from completed challenges: 0 -> 1, n -> n*2 (so 1=>2, 9=>18)
    function ipMultiplierFromChallenges(){
      const completed = infinityChallenges.filter(c=>c.completed).length;
      if (completed <= 0) return 1;
      return completed * 2;
    }

    // update UI throttled
    let lastUI = 0;
    function updateUI_throttled(force){
      const now = performance.now();
      if (!force && now - lastUI < 120) return;
      lastUI = now;

      // compute total multiplier using BigNum fully
      let totalMultBN = BigNum.fromNumber(1);
      for (let i=0;i<upgrades.length;i++){
        const u = upgrades[i];
        const pMult = 0.02 * ((u.prestigeLevel && u.prestigeLevel.mult) || 0);
        const asc = 0.05 * (u.ascendCount || 0);
        const factorBN = BigNum.fromNumber(1);
        factorBN.addInPlace(u._multBN);
        factorBN.addNumber(pMult + asc + (globalPrestige.mAdd || 0));
        totalMultBN.mulInPlace(factorBN);
      }

      const rateBN = baseIncome.clone();
      rateBN.mulInPlace(totalMultBN);
      const prestigeMultNum = prestigeBoostMultiplier();
      rateBN.mulByNumber(prestigeMultNum);
      // challenge final multipliers (active)
      const completed = infinityChallenges.filter(c=>c.completed).length;
      if (completed > 0) rateBN.mulByNumber(1 + completed * 0.02);

      const rateEl = document.getElementById('rate');
      const rateDisplayNum = rateBN.toNumberSafe();
      if (!isFinite(rateDisplayNum) || rateBN.e > 16) rateEl.textContent = rateBN.toString();
      else rateEl.textContent = isFinite(rateDisplayNum) ? rateDisplayNum.toFixed(2) : rateBN.toString();

      document.getElementById('formula').textContent = 'åå…¥ = baseIncome Ã— ... Ã— Prestige(exp) ï¼ˆå€é€Ÿ: ' + speedMultiplier.toFixed(0) + (paused ? ' åœæ­¢ä¸­' : '') + 'ï¼‰';

      for (let i=0;i<upgrades.length;i++){
        const u = upgrades[i], ui = upgradeUI[i];
        if (!ui) continue;
        ui.lvlEl.textContent = u.level;
        ui.capEl.textContent = getLevelCap(u);
        ui.costEl.textContent = getUpgradeCostBig(u,0).toString();
        const multNum = u._multBN.toNumberSafe();
        ui.multEl.textContent = '+' + (isFinite(multNum) ? multNum.toFixed(3) : u._multBN.toString());
        const rateClone = u._rateBN.clone();
        rateClone.mulByNumber(globalPrestige.rMul || 1);
        const rateNum = rateClone.toNumberSafe();
        ui.rateEl.textContent = isFinite(rateNum) ? rateNum.toFixed(2) : rateClone.toString();
        ui.ascEl.textContent = u.ascendCount || 0;
        ui.pLvEl.textContent = (u.prestigeLevel && u.prestigeLevel.mult) || 0;
        ui.pLvREl.textContent = (u.prestigeLevel && u.prestigeLevel.rate) || 0;
        ui.pLvCEl.textContent = (u.prestigeLevel && u.prestigeLevel.cost) || 0;

        if (u.level >= getLevelCap(u)) ui.btnAsc.classList.remove('invisible'); else ui.btnAsc.classList.add('invisible');
        const canBuy = u.level < getLevelCap(u);
        ui.btn1.disabled = !canBuy;
        ui.btn10.disabled = !canBuy;
        ui.btn100.disabled = !canBuy;
        ui.btnMax.disabled = !canBuy;
      }

      // show prestige button when eligible
      const prestigeBtn = document.getElementById('prestigeBtn');
      let canPrestige = false;
      if (money.gteNumber(1e20)) {
        if (prestigeCount === 0) canPrestige = true;
        else {
          if (isMoneyGreaterThan(money, lastPrestigeScore)) canPrestige = true;
        }
      }
      if (canPrestige) prestigeBtn.classList.remove('invisible'); else prestigeBtn.classList.add('invisible');

      // infinity meter / button
      const inftyFill = document.getElementById('inftyFill');
      const inftyBtn = document.getElementById('gainInfinityBtn');
      const pct = computeInfinityProgressPercent(money);
      inftyFill.style.transform = 'scaleX(' + (pct/100) + ')';
      const pctEl = document.getElementById('inftyPct');
      if (pctEl) pctEl.textContent = pct.toFixed(6) + '%';
      // show gain button when >= target OR when Infinity Break active and money>target
      if (money.gteBig(INF_TARGET) || (infinityChallenges.every(c=>c.completed) && money.gteBig(INF_TARGET))) inftyBtn.classList.remove('invisible'); else inftyBtn.classList.add('invisible');

      // display IP, GDP
      document.getElementById('inftyPoints').textContent = infinityPoints.toString();
      document.getElementById('gdpDisp').textContent = gdp.toString();

      // render prestige shop / skill area (safe to call frequently)
      renderPrestigeShop();
    }

    function isMoneyGreaterThan(a,b){
      if (!(a instanceof BigNum)) a = BigNum.fromObject(a);
      if (!(b instanceof BigNum)) b = BigNum.fromObject(b);
      if (a.e !== b.e) return a.e > b.e;
      return Math.abs(a.m) > Math.abs(b.m);
    }

    function costToBuyBig(u, n){
      if (n <= 0) return BigNum.zero();
      const remaining = Math.max(0, getLevelCap(u) - u.level);
      const want = Math.min(n, remaining);
      let total = BigNum.zero();
      for (let k=0;k<want;k++){
        const piece = getUpgradeCostBig(u, k);
        total.addInPlace(piece);
      }
      return total;
    }

    function getMultiplierIncrementBig(u){
      const base = 0.005 * Math.pow(1 + u.level, 0.38);
      const gpPenalty = computeGPPenaltyFactor();
      const genSkillFactor = (window.__genEffBaseFromSkills || 1);
      return BigNum.fromNumber(Math.min(base * gpPenalty * genSkillFactor, 1e12));
    }

    function buyUpgrade(idx, qty, silent){
      const u = upgrades[idx];
      if (u.level >= getLevelCap(u)){ if (!silent) alert('ã“ã®ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã¯æœ€å¤§Lvã§ã™ï¼ˆ' + getLevelCap(u) + 'ï¼‰'); return; }
      if (qty === 'max'){
        const remaining = getLevelCap(u) - u.level;
        let lo = 0, hi = 1;
        while (hi <= remaining && money.gteBig(costToBuyBig(u,hi))) hi *= 2;
        hi = Math.min(hi, remaining);
        while (lo + 1 < hi){
          const mid = Math.floor((lo + hi)/2);
          if (money.gteBig(costToBuyBig(u, mid))) lo = mid;
          else hi = mid;
        }
        if (lo > 0) doPurchase(u, idx, lo);
        else if (!silent) alert('ãŠé‡‘ãŒè¶³ã‚Šã¾ã›ã‚“');
        return;
      }
      const n = Number(qty) || 1;
      const allowed = Math.min(n, getLevelCap(u) - u.level);
      if (allowed <= 0){ if (!silent) alert('ã“ã‚Œä»¥ä¸Šè³¼å…¥ã§ãã¾ã›ã‚“ï¼ˆLvä¸Šé™ï¼‰'); return; }
      const costBN = costToBuyBig(u, allowed);
      if (money.gteBig(costBN)) doPurchase(u, idx, allowed);
      else if (!silent) alert('ãŠé‡‘ãŒè¶³ã‚Šã¾ã›ã‚“');
    }

    function doPurchase(u, idx, n){
      const costBN = costToBuyBig(u, n);
      money.subInPlace(costBN);
      const exponent = n * 0.12;
      const multiplier = Math.pow(Math.max(1, u.speedMult), exponent);
      u._rateBN.mulByNumber(multiplier);
      if (u._rateBN.e > 300) u._rateBN = BigNum.fromNumber(1e300);
      u.level += n;
      saveGame();
      updateUI_throttled(true);
    }

    function tryAscend(i){
      const u = upgrades[i];
      if (u.level < getLevelCap(u)){ alert('Lvä¸Šé™ã«åˆ°é”ã—ã¦ã‹ã‚‰æ˜‡å¤©å¯èƒ½ã§ã™ï¼ˆç¾åœ¨ Lv ' + u.level + ' / ' + getLevelCap(u) + 'ï¼‰'); return; }
      if (!confirm(u.name + ' ã‚’æ˜‡å¤©ã—ã¾ã™ã‹ï¼Ÿ LvãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã€æ°¸ç¶šãƒœãƒ¼ãƒŠã‚¹ãŒä»˜ä¸ã•ã‚Œã¾ã™ã€‚')) return;
      u.ascendCount = (u.ascendCount || 0) + 1;
      u.purchasePenalty = (u.purchasePenalty || 0) + 0.25;
      u.level = 0;
      u.progress = 0;
      u._rateBN = BigNum.fromNumber(u.baseRate || 1);
      u._multBN = BigNum.zero();
      saveGame();
      updateUI_throttled(true);
      alert(u.name + ' ã‚’æ˜‡å¤©ã—ã¾ã—ãŸï¼ˆæ˜‡å¤©å›æ•°: ' + u.ascendCount + 'ï¼‰\nè©²å½“ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®ã‚³ã‚¹ãƒˆãŒæ°¸ç¶šã§ +25% ã•ã‚Œã¾ã—ãŸã€‚');
    }

    // PRESTIGE logic
    function prestigePointsForScore(bn){
      if (!(bn instanceof BigNum)) bn = BigNum.fromObject(bn);
      if (bn.m === 0) return 0;
      const mantLog = Math.log10(Math.abs(bn.m));
      const log10val = bn.e + mantLog;
      const diff = log10val - 20;
      if (!isFinite(diff) || diff < 0) return 0;
      const points = Math.floor(diff) + 1;
      return points;
    }

    function doPrestige(force){
      let can = false;
      if (money.gteNumber(1e20)){
        if (prestigeCount === 0) can = true;
        else if (isMoneyGreaterThan(money, lastPrestigeScore)) can = true;
      }
      if (!force && !can){ alert('ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã›ã‚“'); return; }
      if (!force && !confirm('ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’å®Ÿè¡Œã—ã¾ã™ã‹ï¼Ÿï¼ˆå…¨ã¦ãƒªã‚»ãƒƒãƒˆã€ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ãƒã‚¤ãƒ³ãƒˆä»˜ä¸ã€‚ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ã¯å‰å›ã‚ˆã‚Šé«˜ã„ã‚¹ã‚³ã‚¢ã§ã®ã¿å†åº¦å¯èƒ½ï¼‰')) return;

      const pts = prestigePointsForScore(money);
      if (pts <= 0 && !force){ alert('ã‚¹ã‚³ã‚¢ãŒä¸ååˆ†ã§ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ãƒã‚¤ãƒ³ãƒˆã¯å¾—ã‚‰ã‚Œã¾ã›ã‚“'); return; }

      prestigePoints += pts;
      prestigeCount += 1;
      lastPrestigeScore = money.clone();

      money = BigNum.zero();
      baseIncome = BigNum.fromNumber(1);
      upgrades = cloneTemplate();
      sanitizeUpgrades(upgrades);
      saveGame();
      initUI();
      updateUI_throttled(true);
      alert('ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸å®Œäº†: prestigePoints +' + pts + '\nç¾åœ¨ã®ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ãƒã‚¤ãƒ³ãƒˆ: ' + prestigePoints);
    }

    // GAIN INFINITY (IP)
    function computeInfinityProgressPercent(bn){
      if (!(bn instanceof BigNum)) bn = BigNum.fromObject(bn);
      if (bn.m === 0) return 0;
      const logVal = bigNumLog10(bn);
      const logStart = 0;
      const logTarget = bigNumLog10(INF_TARGET);
      if (!isFinite(logVal)) return 0;
      if (logVal < logStart) return 0;
      if (logVal >= logTarget) return 100;
      const pct = (logVal - logStart) / (logTarget - logStart) * 100;
      return Math.max(0, Math.min(100, pct));
    }

    function gainInfinity(){
      // if not at INF_TARGET and not InfinityBreak -> stop
      const isBreak = infinityChallenges.every(c=>c.completed);
      if (!money.gteBig(INF_TARGET) && !isBreak){ alert('ã¾ã ç„¡é™ã«åˆ°é”ã—ã¦ã„ã¾ã›ã‚“'); return; }
      if (!confirm('ç„¡é™ã‚’å–å¾—ã—ã¾ã™ã‹ï¼Ÿï¼ˆGenerationã‚’å…¨ã¦ãƒªã‚»ãƒƒãƒˆã—ã€ç„¡é™ãƒã‚¤ãƒ³ãƒˆ (IP) ã‚’ç²å¾—ï¼‰')) return;

      // compute IP gain:
      // base 1 IP for normal reach.
      // If Infinity Break (all 9 completed) and money >> INF_TARGET, extra IP = floor(log10(money) - log10(INF_TARGET)) * ipMultiplier
      let baseIP = BigNum.fromNumber(1);
      const ipMult = ipMultiplierFromChallenges();
      if (isBreak && money.gteBig(INF_TARGET)){
        const deltaLog = Math.max(0, bigNumLog10(money) - bigNumLog10(INF_TARGET));
        const extra = Math.floor(deltaLog);
        if (extra > 0){
          const extraBN = BigNum.fromNumber(extra * ipMult);
          baseIP.addInPlace(extraBN);
        } else {
          // even if no extra orders, still add ipMult if at least one challenge completed? Keep base 1 * ipMult
          if (ipMult > 1) {
            baseIP = BigNum.fromNumber(1 * ipMult);
          }
        }
      } else {
        // normal: base 1 IP multiplied by ip multiplier from challenges (if some completed)
        baseIP = BigNum.fromNumber(1 * ipMult);
      }

      infinityPoints.addInPlace(baseIP);

      // Reset generation, but keep skillNodes, mines, infinityPoints, generators/IP/GP?
      money = BigNum.zero();
      baseIncome = BigNum.fromNumber(1);
      upgrades = cloneTemplate();
      sanitizeUpgrades(upgrades);
      prestigePoints = 0;
      prestigeCount = 0;
      prestigeMult = BigNum.fromNumber(1);
      lastPrestigeScore = BigNum.zero();
      costBaseMultVar = 1.15;
      Object.assign(globalPrestige, JSON.parse(JSON.stringify(baseGlobalPrestige)));
      speedMultiplier = 1.0;
      paused = false;
      applySkillEffects();
      updateUI_throttled(true);
      saveGame();
      alert('ç„¡é™ã‚’ç²å¾—ã—ã¾ã—ãŸï¼ IP +' + baseIP.toString());
    }

    // full reset
    function fullReset(){
      try { localStorage.removeItem('idle_all_big_save'); } catch(e){}
      try { localStorage.removeItem(SKILL_STORAGE_KEY); } catch(e){}
      try { localStorage.removeItem(INF_CHALLENGE_STORAGE); } catch(e){}
      money = BigNum.zero();
      baseIncome = BigNum.fromNumber(1);
      upgrades = cloneTemplate();
      sanitizeUpgrades(upgrades);
      prestigePoints = 0;
      prestigeCount = 0;
      prestigeMult = BigNum.fromNumber(1);
      lastPrestigeScore = BigNum.zero();
      infinityPoints = BigNum.zero();
      costBaseMultVar = 1.15;
      Object.assign(globalPrestige, JSON.parse(JSON.stringify(baseGlobalPrestige)));
      generatorPoints = 0;
      generators = [];
      ensureInitialGenerators();
      minesCount = 0;
      gdp = BigNum.zero();
      infinityChallenges.forEach(c=>{ c.active=false; c.completed=false; });
      speedMultiplier = 1.0;
      paused = false;
      displayMoneyNum = 0;
      prevProgress = new Array(upgrades.length).fill(0);
      currProgress = new Array(upgrades.length).fill(0);
      skillNodes.forEach(s=>s.purchased=false);
      saveSkillNodes();
      saveGame();
      initUI();
      updateUI_throttled(true);
    }

    // Save / Load
    function saveGame(){
      try {
        const save = {
          money: money.toObject(),
          baseIncome: baseIncome.toObject(),
          upgrades: upgrades.map(u => ({
            name:u.name, baseRate:u.baseRate,
            rateBN: u._rateBN.toObject(), multBN: u._multBN.toObject(), baseCostBN: u._baseCostBN.toObject(),
            baseCost: u.baseCost, level: u.level, progress: u.progress, prestigeLevel: u.prestigeLevel || {mult:0,rate:0,cost:0}, ascendCount: u.ascendCount || 0, purchasePenalty: u.purchasePenalty || 0
          })),
          prestigePoints,
          prestigeCount,
          prestigeMult: prestigeMult.toObject(),
          lastPrestigeScore: lastPrestigeScore.toObject(),
          infinityPoints: infinityPoints.toObject(),
          globalPrestige,
          costBaseMultVar,
          speedMultiplier,
          paused,
          generatorPoints,
          generators,
          minesCount,
          gdp: gdp.toObject(),
          gpPenaltyFactorBase,
          genCostScale,
          challenges: infinityChallenges.map(c => ({id:c.id, active:c.active, completed:c.completed}))
        };
        localStorage.setItem('idle_all_big_save', JSON.stringify(save));
        saveSkillNodes();
      } catch(e){ console.warn('save fail', e); try{ localStorage.removeItem('idle_all_big_save'); }catch(e){} }
    }

    function loadGame(){
      try {
        const raw = localStorage.getItem('idle_all_big_save');
        if (!raw) return;
        let data;
        try { data = JSON.parse(raw); } catch(parseErr){ console.warn('save parse failed, clearing', parseErr); localStorage.removeItem('idle_all_big_save'); return; }
        if (!data || typeof data !== 'object') return;

        if (data.money && typeof data.money.m === 'number') money = BigNum.fromObject(data.money);
        if (data.baseIncome && typeof data.baseIncome.m === 'number') baseIncome = BigNum.fromObject(data.baseIncome);

        if (Array.isArray(data.upgrades) && data.upgrades.length === upgradesTemplate.length){
          upgrades = data.upgrades.map((s,i) => {
            const t = JSON.parse(JSON.stringify(upgradesTemplate[i]));
            const merged = Object.assign(t, s);
            merged._rateBN = (s && s.rateBN) ? BigNum.fromObject(s.rateBN) : BigNum.fromNumber(merged.rate || merged.baseRate || 1);
            merged._multBN = (s && s.multBN) ? BigNum.fromObject(s.multBN) : BigNum.fromNumber(merged.mult || 0);
            merged._baseCostBN = (s && s.baseCostBN) ? BigNum.fromObject(s.baseCostBN) : BigNum.fromNumber(merged.baseCost || upgradesTemplate[i].baseCost);
            merged.level = Number.isFinite(+merged.level) ? Math.max(0, Math.floor(+merged.level)) : 0;
            merged.progress = Number.isFinite(+merged.progress) ? +merged.progress : 0;
            merged.prestigeLevel = merged.prestigeLevel || {mult:0,rate:0,cost:0};
            merged.ascendCount = Number.isFinite(+merged.ascendCount) ? +merged.ascendCount : 0;
            merged.purchasePenalty = Number.isFinite(+merged.purchasePenalty) ? +merged.purchasePenalty : 0;
            return merged;
          });
        }

        if (typeof data.prestigePoints === 'number') prestigePoints = data.prestigePoints;
        if (typeof data.prestigeCount === 'number') prestigeCount = data.prestigeCount;
        if (data.prestigeMult && typeof data.prestigeMult.m === 'number') prestigeMult = BigNum.fromObject(data.prestigeMult);
        if (data.lastPrestigeScore && typeof data.lastPrestigeScore.m === 'number') lastPrestigeScore = BigNum.fromObject(data.lastPrestigeScore);

        if (data.infinityPoints && typeof data.infinityPoints.m === 'number') infinityPoints = BigNum.fromObject(data.infinityPoints);

        if (data.globalPrestige && typeof data.globalPrestige === 'object') Object.assign(globalPrestige, data.globalPrestige);
        if (typeof data.costBaseMultVar === 'number') costBaseMultVar = data.costBaseMultVar;
        if (typeof data.speedMultiplier === 'number') speedMultiplier = Math.max(1, Math.min(3, Math.round(data.speedMultiplier)));
        if (typeof data.paused === 'boolean') paused = !!data.paused;

        if (typeof data.generatorPoints === 'number') generatorPoints = data.generatorPoints;
        if (Array.isArray(data.generators) && data.generators.length >= 1){
          generators = data.generators.map(g => ({
            count: Number.isFinite(+g.count) ? Math.max(0, Math.floor(+g.count)) : 0,
            progress: Number.isFinite(+g.progress) ? +g.progress : 0
          }));
        }

        if (typeof data.minesCount === 'number') minesCount = data.minesCount;
        if (data.gdp && typeof data.gdp.m === 'number') gdp = BigNum.fromObject(data.gdp);
        if (typeof data.gpPenaltyFactorBase === 'number') gpPenaltyFactorBase = data.gpPenaltyFactorBase;
        if (typeof data.genCostScale === 'number') genCostScale = data.genCostScale;

        if (Array.isArray(data.challenges)){
          data.challenges.forEach(sc => {
            const c = infinityChallenges.find(x => x.id === sc.id);
            if (c){ c.active = !!sc.active; c.completed = !!sc.completed; }
          });
        }

        sanitizeUpgrades(upgrades);
      } catch(e){ console.warn('loadGame failed, clearing save', e); try{ localStorage.removeItem('idle_all_big_save'); }catch(e){} }
    }

    function saveChallenges(){ try{ localStorage.setItem(INF_CHALLENGE_STORAGE, JSON.stringify(infinityChallenges.map(c=>({id:c.id, active:c.active, completed:c.completed})))) }catch(e){console.warn(e);} }
    function loadChallenges(){ try{ const raw = localStorage.getItem(INF_CHALLENGE_STORAGE); if (!raw) return; const arr = JSON.parse(raw); arr.forEach(a=>{ const c = infinityChallenges.find(x=>x.id===a.id); if(c){ c.active=!!a.active; c.completed=!!a.completed; } }); }catch(e){console.warn(e);} }

    // Simulation + render
    sanitizeUpgrades(upgrades);
    loadGame();
    loadSkillNodes();
    loadChallenges();
    applySkillEffects();
    sanitizeUpgrades(upgrades);
    initUI();
    updateUI_throttled(true);

    const FIXED_DT = 0.05;
    let accumulator = 0;
    let lastTime = performance.now();
    let displayMoneyNum = 0;
    let prevProgress = new Array(upgrades.length).fill(0);
    let currProgress = new Array(upgrades.length).fill(0);

    // ensure IP BigNum initial
    if (!(infinityPoints instanceof BigNum)) infinityPoints = BigNum.fromNumber(Number(infinityPoints) || 0);

    // generator simulation
    function simulateGenerators(dt){
      // G1 generates GP (generatorPoints)
      if (generators.length === 0) ensureInitialGenerators();
      const g1count = generators[0].count || 0;
      const g1PerSecPer = 0.001 * (window.__genEffMultiplier || 1);
      const gpGain = g1count * g1PerSecPer * dt;
      if (gpGain > 0) generatorPoints += gpGain;

      // higher tiers produce lower tiers
      for (let tier = 1; tier < generators.length; tier++){
        const g = generators[tier];
        if (!g || g.count <= 0) continue;
        const perSec = 0.1 * g.count * (window.__genEffMultiplier || 1);
        g.progress += perSec * dt;
        if (g.progress >= 1){
          const inc = Math.floor(g.progress);
          g.progress -= inc;
          generators[tier-1].count += inc;
        }
      }

      // Mines produce GDP
      if (minesCount > 0){
        const basePerMine = gdpPerMinePerSec * (1 + skillNodes.filter(s=>s.purchased && s.effect.type==='mineBonus').length * 0.05);
        const gdpGain = minesCount * basePerMine * dt;
        const addBN = BigNum.fromNumber(gdpGain);
        gdp.addInPlace(addBN);
      }
    }

    // step simulation
    function simulateStep(dt){
      const s = speedMultiplier;
      for (let i=0;i<upgrades.length;i++){
        const u = upgrades[i];
        prevProgress[i] = currProgress[i];
        let progRate = NaN;
        try { progRate = (u._rateBN && typeof u._rateBN.toNumberSafe === 'function') ? u._rateBN.toNumberSafe() : NaN; } catch(e){ progRate = NaN; }
        if (!isFinite(progRate) || progRate <= 0) progRate = (u.baseRate || 0.01);
        progRate *= (globalPrestige.rMul || 1);
        let incProg = progRate * dt * 100 * s;
        if (!isFinite(incProg)) incProg = 0;
        currProgress[i] += incProg;
        if (currProgress[i] > PROGRESS_CAP) currProgress[i] = PROGRESS_CAP;
        if (currProgress[i] >= 100){
          let completed = Math.floor(currProgress[i] / 100);
          if (completed > 1000000) completed = 1000000;
          currProgress[i] -= completed * 100;
          const incBaseBN = getMultiplierIncrementBig(u);
          incBaseBN.mulByNumber(completed);
          u._multBN.addInPlace(incBaseBN);
          if (u._multBN.e > 300) u._multBN = BigNum.fromNumber(1e300);
        }
        u.progress = currProgress[i];
      }

      let totalMultBN = BigNum.fromNumber(1);
      for (let i=0;i<upgrades.length;i++){
        const u = upgrades[i];
        const pMult = 0.02 * ((u.prestigeLevel && u.prestigeLevel.mult) || 0);
        const asc = 0.05 * (u.ascendCount || 0);
        const factorBN = BigNum.fromNumber(1);
        factorBN.addInPlace(u._multBN);
        factorBN.addNumber(pMult + asc + (globalPrestige.mAdd || 0));
        totalMultBN.mulInPlace(factorBN);
      }

      const addBN = baseIncome.clone();
      addBN.mulInPlace(totalMultBN);
      const prestigeMultNum = prestigeBoostMultiplier();
      addBN.mulByNumber(prestigeMultNum);
      // apply some challenge reward if active (example)
      infinityChallenges.forEach(c => { if (!c.active) return; if (c.reward && c.reward.type==='finalMult') addBN.mulByNumber(c.reward.value); });
      // softcap internal (no tuning UI)
      const softMult = softCapMultiplierForScore(money);
      addBN.mulByNumber(softMult);

      addBN.mulByNumber(dt * s);
      money.addInPlace(addBN);

      // clamp money to INF_TARGET UNLESS Infinity Break (all 9 completed)
      if (!infinityChallenges.every(c=>c.completed)){
        if (money.gteBig(INF_TARGET)) { money = INF_TARGET.clone(); }
      }

      // simulate gens & mines
      simulateGenerators(dt);
      // update gen eff multiplier including GDP impact and gp penalty
      const skillBase = window.__genEffBaseFromSkills || 1;
      const gpPenalty = computeGPPenaltyFactor();
      window.__genEffMultiplier = skillBase * (1 + minesCount * 0.05) * (1 + (gdp.toNumberSafe ? gdp.toNumberSafe() * 1e-6 : 0)) * gpPenalty;
    }

    // render loop
    function render(){
      const now = performance.now();
      let frameDelta = (now - lastTime) / 1000;
      if (!isFinite(frameDelta) || frameDelta <= 0) frameDelta = 0;
      lastTime = now;
      if (frameDelta > 0.5) frameDelta = 0.5;
      accumulator += frameDelta;
      if (accumulator > 0.5) accumulator = 0.5;

      if (!paused){
        while (accumulator >= FIXED_DT){
          simulateStep(FIXED_DT);
          accumulator -= FIXED_DT;
        }
      } else {
        accumulator = 0;
        for (let i=0;i<upgrades.length;i++) prevProgress[i] = currProgress[i];
      }

      const alpha = FIXED_DT === 0 ? 0 : (accumulator / FIXED_DT);

      // money display
      if (money.m === 0){
        displayMoneyNum += (0 - displayMoneyNum) * 0.12;
        document.getElementById('money').textContent = fmtSmall(displayMoneyNum);
      } else if (money.e <= 12){
        const v = money.toNumberSafe();
        if (isFinite(v)){
          displayMoneyNum += (v - displayMoneyNum) * 0.12;
          document.getElementById('money').textContent = fmtSmall(displayMoneyNum);
        } else {
          document.getElementById('money').textContent = money.toString();
        }
      } else {
        document.getElementById('money').textContent = money.toString();
      }

      for (let i=0;i<upgrades.length;i++){
        const interp = prevProgress[i] + (currProgress[i] - prevProgress[i]) * alpha;
        const w = Math.min(Math.max(interp, 0), 100);
        const el = upgradeUI[i] && upgradeUI[i].fillEl;
        if (el){
          const scale = Math.max(0, Math.min(1, w / 100));
          el.style.transform = 'scaleX(' + scale + ')';
        }
      }

      updateUI_throttled();
      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

    // wiring events
    const prestigeBtn = document.getElementById('prestigeBtn');
    prestigeBtn.addEventListener('click', ()=> doPrestige(false));

    const inftyBtn = document.getElementById('gainInfinityBtn');
    if (inftyBtn) inftyBtn.addEventListener('click', gainInfinity);
    window.addEventListener('beforeunload', ()=> saveGame());

    const resetBtn = document.getElementById('resetBtn');
    resetBtn.addEventListener('click', ()=> {
      if (!confirm('æœ¬å½“ã«ã‚»ãƒ¼ãƒ–ã‚’å‰Šé™¤ã—ã¦ã‚²ãƒ¼ãƒ ã‚’å®Œå…¨ã«åˆæœŸåŒ–ã—ã¾ã™ã‹ï¼Ÿï¼ˆå…ƒã«æˆ»ã›ã¾ã›ã‚“ï¼‰')) return;
      fullReset();
      alert('ã‚²ãƒ¼ãƒ ã‚’å®Œå…¨ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚ã‚»ãƒ¼ãƒ–ã‚‚å‰Šé™¤ã•ã‚Œã¦ã„ã¾ã™ã€‚');
    });

    // auto-buy
    setInterval(function(){
      try {
        const autoOn = document.getElementById('autoToggle').checked && prestigeCount >= 1;
        if (!autoOn) return;
        const qty = document.getElementById('autoQty').value;
        const order = upgrades.map((u,i)=>({i,c:getUpgradeCostBig(u)})).sort((a,b)=>{
          if (a.c.e !== b.c.e) return a.c.e - b.c.e;
          return Math.abs(a.c.m) - Math.abs(b.c.m);
        });
        for (let k=0;k<order.length;k++){
          const entry = order[k];
          if (upgrades[entry.i].level >= getLevelCap(upgrades[entry.i])) continue;
          if (money.gteBig(entry.c)){
            buyUpgrade(entry.i, qty, true);
            break;
          }
        }
      } catch(e){ console.warn('auto-buy error', e); }
    }, 900);

    // speed UI
    const speedSelect = document.getElementById('speedSelect');
    const speedInc = document.getElementById('speedInc');
    const speedDec = document.getElementById('speedDec');
    const pauseBtn = document.getElementById('pauseBtn');
    let speedMultiplier = 1.0;
    let paused = false;
    function clampSpeed(v){ return Math.max(1, Math.min(3, Math.round(v))); }
    function updateSpeedUI(force){
      speedMultiplier = clampSpeed(speedMultiplier);
      speedSelect.value = String(speedMultiplier);
      pauseBtn.textContent = paused ? 'å†é–‹' : 'ä¸€æ™‚åœæ­¢';
      if (force) updateUI_throttled(true);
      saveGame();
    }
    speedSelect.addEventListener('change', ()=> { speedMultiplier = clampSpeed(Number(speedSelect.value)); updateSpeedUI(true); });
    speedInc.addEventListener('click', ()=> { speedMultiplier = clampSpeed(speedMultiplier + 1); updateSpeedUI(true); });
    speedDec.addEventListener('click', ()=> { speedMultiplier = clampSpeed(speedMultiplier - 1); updateSpeedUI(true); });
    pauseBtn.addEventListener('click', ()=> { paused = !paused; if (paused) accumulator = 0; updateSpeedUI(true); });
    window.addEventListener('keydown', (e) => {
      if (e.key === '['){ speedMultiplier = clampSpeed(speedMultiplier - 1); updateSpeedUI(true); e.preventDefault(); }
      else if (e.key === ']'){ speedMultiplier = clampSpeed(speedMultiplier + 1); updateSpeedUI(true); e.preventDefault(); }
      else if (e.code === 'Space'){ paused = !paused; if (paused) accumulator = 0; updateSpeedUI(true); e.preventDefault(); }
    });

    updateSpeedUI(true);

    // ---- Infinity shop / Generators / Mines logic ----

    // generator cost formula (IP-based): cost = ceil(base * genCostScale^(count))
    function genTierCostIP(tierIndex, count){
      // cost grows faster with tierIndex (higher tier more expensive baseline)
      const base = genBaseForTier(tierIndex);
      return Math.ceil(base * Math.pow(genCostScale, count));
    }
    function genBaseForTier(tierIndex){
      // base grows exponentially with tierIndex so higher tiers start expensive
      return genBaseCostBase * Math.pow(8, tierIndex); // tuneable
    }

    // buy generator with IP
    function buyGeneratorWithIP(tier, qty){
      qty = Number(qty) || 1;
      if (qty <= 0) return;
      // ensure tier exists
      while (tier >= generators.length) generators.push({count:0,progress:0});
      const cur = generators[tier].count || 0;
      let totalCost = 0;
      for (let k=0;k<qty;k++){
        totalCost += genTierCostIP(tier, cur + k);
      }
      const costBN = BigNum.fromNumber(totalCost);
      if (infinityPoints.ltBig(costBN)){ alert('IPãŒè¶³ã‚Šã¾ã›ã‚“'); return; }
      infinityPoints.subInPlace(costBN);
      generators[tier].count += qty;
      // gentle side-effect: buying high tiers increases gpPenaltyFactor (makes it harder)
      gpPenaltyFactorBase += 0.0005 * qty;
      saveGame();
      updateUI_throttled(true);
      alert(`G${tier+1} ã‚’ ${qty} å€‹è³¼å…¥ã—ã¾ã—ãŸï¼ˆIP -${costBN.toString()}ï¼‰`);
    }

    // allow adding new generator tier purchase (makes infinite tiers possible)
    function buyNextTierOnce(){
      const nextTier = generators.length;
      // set a cost to unlock next tier in IP
      const unlockCost = BigNum.fromNumber(Math.ceil(genBaseForTier(nextTier) * Math.pow(genCostScale, 0)));
      if (infinityPoints.ltBig(unlockCost)){ alert('IPãŒè¶³ã‚Šã¾ã›ã‚“ï¼ˆæ¬¡ã®ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼éšå±¤ã®è§£æ”¾ï¼‰'); return; }
      infinityPoints.subInPlace(unlockCost);
      generators.push({count:1, progress:0}); // give 1 unit on unlock
      saveGame();
      updateUI_throttled(true);
      alert('æ–°ã—ã„ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼éšå±¤ã‚’è§£æ”¾ã—ã¾ã—ãŸï¼ˆG' + (nextTier+1) + ' ãŒ +1 æ‰€æŒï¼‰');
    }

    // Mines IP cost
    function mineCostIP(qty){
      let total = 0;
      for (let i=0;i<qty;i++){
        total += Math.ceil(minesBaseIP * Math.pow(minesIPScale, minesCount + i));
      }
      return BigNum.fromNumber(total);
    }
    function buyMineWithIP(qty){
      qty = Number(qty) || 1;
      if (qty <= 0) return;
      const cost = mineCostIP(qty);
      if (infinityPoints.ltBig(cost)){ alert('IPãŒè¶³ã‚Šã¾ã›ã‚“'); return; }
      infinityPoints.subInPlace(cost);
      minesCount += qty;
      // immediate effect reflected in simulateGenerators via window.__genEffMultiplier
      saveGame();
      updateUI_throttled(true);
      alert(`Mine ã‚’ ${qty} å€‹è³¼å…¥ã—ã¾ã—ãŸï¼ˆIP -${cost.toString()}ï¼‰`);
    }

    // spend GDP to boost generator efficiency (consumable)
    function spendGDPBoostAll(percent, gdpCost){
      // percent: e.g., 0.05 for +5% generator efficiency
      const costBN = BigNum.fromNumber(gdpCost);
      if (gdp.ltBig(costBN)){ alert('GDPãŒè¶³ã‚Šã¾ã›ã‚“'); return; }
      gdp.subInPlace(costBN);
      // apply permanent-ish boost: reduce gpPenaltyFactorBase slightly (effectively increases efficiency)
      gpPenaltyFactorBase = Math.max(0.001, gpPenaltyFactorBase - percent * 0.02);
      saveGame();
      updateUI_throttled(true);
      alert('GDPã‚’æ¶ˆè²»ã—ã¾ã—ãŸã€‚ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼åŠ¹ç‡ãŒå‘ä¸Šã—ã¾ã—ãŸã€‚');
    }

    // Challenges controls
    function startChallenge(id){
      if (infinityChallenges.some(c=>c.active)) { alert('æ—¢ã«ãƒãƒ£ãƒ¬ãƒ³ã‚¸ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã™ã€‚ã¾ãšã¯è§£é™¤ã—ã¦ãã ã•ã„ã€‚'); return; }
      const c = infinityChallenges.find(x=>x.id===id);
      if (!c) return;
      if (!confirm(`${c.name} ã‚’é–‹å§‹ã—ã¾ã™ã‹ï¼Ÿ\nåŠ¹æœ: ${c.desc}\né–‹å§‹ã™ã‚‹ã¨GenerationãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚`)) return;
      c.active = true;
      // reset Generation but keep IP/skills/mines
      money = BigNum.zero();
      baseIncome = BigNum.fromNumber(1);
      upgrades = cloneTemplate();
      sanitizeUpgrades(upgrades);
      prestigePoints = 0;
      prestigeCount = 0;
      lastPrestigeScore = BigNum.zero();
      applySkillEffects();
      saveChallenges();
      saveGame();
      initUI();
      updateUI_throttled(true);
      alert('ãƒãƒ£ãƒ¬ãƒ³ã‚¸é–‹å§‹: ' + c.name);
    }
    function stopChallenge(id){
      const c = infinityChallenges.find(x=>x.id===id);
      if (!c) return;
      if (!c.active) return;
      if (!confirm(`${c.name} ã‚’åœæ­¢ã—ã¾ã™ã‹ï¼Ÿ`)) return;
      c.active = false;
      saveChallenges();
      saveGame();
      updateUI_throttled(true);
      alert('ãƒãƒ£ãƒ¬ãƒ³ã‚¸åœæ­¢: ' + c.name);
    }
    function completeChallengeManual(id){
      const c = infinityChallenges.find(x=>x.id===id);
      if (!c) return;
      if (!confirm(`${c.name} ã‚’é”æˆæ‰±ã„ã«ã—ã¾ã™ã‹ï¼Ÿï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰`)) return;
      c.completed = true;
      c.active = false;
      saveChallenges();
      saveGame();
      updateUI_throttled(true);
      alert('ãƒãƒ£ãƒ¬ãƒ³ã‚¸é”æˆ: ' + c.name + '\nç¾åœ¨ã® IP å€ç‡: Ã—' + ipMultiplierFromChallenges());
    }

    // Skill UI (IP sequential purchase)
    function initSkillUI(shop){
      const prev = shop.querySelector('#skillArea');
      if (prev) prev.remove();
      const skillCard = document.createElement('div');
      skillCard.id = 'skillArea';
      skillCard.className = 'card col';
      skillCard.innerHTML = `<div><strong>ç„¡é™ã‚¹ã‚­ãƒ«ãƒ„ãƒªãƒ¼ï¼ˆIP ã§é †æ¬¡è³¼å…¥ï¼‰</strong></div><div class="small">1 â†’ 2 â†’ ... ã®é †ã§è³¼å…¥ã€‚50 ç•ªã‚’è³¼å…¥ã™ã‚‹ã¨ Mines ãŒè§£æ”¾ã•ã‚Œã¾ã™ã€‚</div>`;
      const grid = document.createElement('div');
      grid.className = 'skillsGrid';
      skillNodes.forEach((s, idx) => {
        const btn = document.createElement('button');
        btn.className = 'skillBtn' + (s.purchased ? ' purchased' : '');
        btn.id = 'skillBtn_' + idx;
        btn.textContent = `${s.name}\nCost: ${s.cost} IP\n${s.purchased ? 'Purchased' : 'Buy'}`;
        btn.addEventListener('click', ()=>{
          const detail = `ID:${s.id}\n${s.name}\nEffect: ${s.effect.type} ${JSON.stringify(s.effect.value)}\nCost: ${s.cost} IP\nPurchased: ${s.purchased ? 'Yes' : 'No'}`;
          if (s.purchased){ alert(detail); return; }
          // sequential purchase rule
          const firstNot = skillNodes.findIndex(x=>!x.purchased);
          if (firstNot !== idx){ alert('å…ˆã«å‰ã®ã‚¹ã‚­ãƒ«ã‚’è³¼å…¥ã—ã¦ãã ã•ã„ï¼ˆé †ç•ªã«è³¼å…¥ï¼‰'); return; }
          if (!confirm(detail + '\n\nè³¼å…¥ã—ã¾ã™ã‹ï¼Ÿï¼ˆIP ã‚’æ¶ˆè²»ï¼‰')) return;
          // check IP
          const costBN = BigNum.fromNumber(s.cost);
          if (infinityPoints.ltBig(costBN)){ alert('IP ãŒè¶³ã‚Šã¾ã›ã‚“'); return; }
          infinityPoints.subInPlace(costBN);
          s.purchased = true;
          saveSkillNodes();
          applySkillEffects();
          saveGame();
          initSkillUI(shop);
          updateUI_throttled(true);
          alert('è³¼å…¥ã—ã¾ã—ãŸ: ' + s.name + (idx === SKILL_COUNT-1 ? '\n50ç•ªã‚’è³¼å…¥ã—ãŸãŸã‚ Mines ãŒè§£æ”¾ã•ã‚Œã¾ã—ãŸ' : ''));
        });
        grid.appendChild(btn);
      });
      skillCard.appendChild(grid);
      shop.appendChild(skillCard);
    }

    // Render prestigeShop (Generation tab). NOTE: removed softcap tuning UI per request.
    function renderPrestigeShop(){
      const shop = document.getElementById('prestigeShop');
      if (!shop) return;
      shop.innerHTML = '';

      // Skill tree
      initSkillUI(shop);

      // Prestige info
      const info = document.createElement('div'); info.className='card';
      info.innerHTML = `<div><strong>ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ãƒã‚¤ãƒ³ãƒˆ: ${prestigePoints}</strong></div><div class="small">ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸å›æ•°: ${prestigeCount}</div>`;
      shop.appendChild(info);

      // Prestige items (purchasable with prestigePoints) - kept small
      const prestigeItems = [
        { id:'m_add', title:'å…¨ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ m +0.01', cost:2, apply(){ globalPrestige.mAdd += 0.01; } },
        { id:'r_mul', title:'å…¨ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ r Ã—1.05', cost:3, apply(){ globalPrestige.rMul *= 1.05; } },
        { id:'cost_dec', title:'å…¨ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ ã‚³ã‚¹ãƒˆ -10%', cost:4, apply(){ globalPrestige.costMul *= 0.90; } },
      ];
      prestigeItems.forEach(item => {
        const card = document.createElement('div'); card.className='card';
        card.innerHTML = `<div><strong>${item.title}</strong></div><div class="small">Cost: ${item.cost} pts</div>`;
        const btn = document.createElement('button'); btn.className='btn btn-small'; btn.textContent='Buy';
        btn.addEventListener('click', ()=>{
          if (prestigePoints >= item.cost){
            prestigePoints -= item.cost;
            item.apply();
            saveGame();
            updateUI_throttled(true);
            alert('è³¼å…¥ã—ã¾ã—ãŸ: ' + item.title);
          } else alert('ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ãƒã‚¤ãƒ³ãƒˆãŒè¶³ã‚Šã¾ã›ã‚“');
        });
        card.appendChild(btn);
        shop.appendChild(card);
      });

      // IP / GP / Mines info
      const ipCard = document.createElement('div'); ipCard.className='card';
      ipCard.innerHTML = `<div><strong>ç„¡é™ãƒã‚¤ãƒ³ãƒˆ(IP): ${infinityPoints.toString()}</strong></div><div class="small">GP: ${generatorPoints.toFixed(4)} â€” Mines: ${minesCount} â€” GDP: ${gdp.toString()}</div>
        <div class="small">IP multiplier (é”æˆæ¸ˆã¿ãƒãƒ£ãƒ¬ãƒ³ã‚¸æ•°ã«ä¾å­˜): Ã—${ipMultiplierFromChallenges()}</div>`;
      shop.appendChild(ipCard);

      // Generators area: show current tiers up to last + 3
      const genCard = document.createElement('div'); genCard.className='card col';
      genCard.innerHTML = `<div><strong>Generators â€” IPã§è³¼å…¥ï¼ˆç„¡é™éšå±¤å¯¾å¿œï¼‰</strong></div><div class="small">GPã¯G1ãŒç”Ÿæˆã€‚é«˜ä½ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã¯ä½ä½ã‚’å¢—ã‚„ã™ã€‚è³¼å…¥ã§éšå±¤ã‚’æ‹¡å¼µã§ãã¾ã™ã€‚</div>`;
      const maxShow = Math.min(generators.length + 3, generators.length + 12); // show some next tiers
      for (let t=0;t<maxShow;t++){
        const g = generators[t] || {count:0,progress:0};
        const nextCost = genTierCostIP(t, g.count || 0);
        const line = document.createElement('div'); line.style.display='flex'; line.style.gap='8px'; line.style.alignItems='center';
        line.innerHTML = `<div style="flex:1"><strong>G${t+1}</strong> â€” æ‰€æŒ: <span id="gcount${t}">${g.count||0}</span></div><div class="small">æ¬¡: ${nextCost} IP</div>`;
        const buyBtn = document.createElement('button'); buyBtn.className='btn btn-small'; buyBtn.textContent='Buy Ã—1';
        buyBtn.addEventListener('click', ()=> buyGeneratorWithIP(t, 1));
        const buy5 = document.createElement('button'); buy5.className='btn btn-small'; buy5.textContent='Buy Ã—5';
        buy5.addEventListener('click', ()=> buyGeneratorWithIP(t, 5));
        line.appendChild(buyBtn); line.appendChild(buy5);
        genCard.appendChild(line);
      }
      // button to unlock next tier (infinite)
      const unlockLine = document.createElement('div'); unlockLine.style.marginTop='6px';
      const unlockBtn = document.createElement('button'); unlockBtn.className='btn btn-small'; unlockBtn.textContent = 'æ¬¡ã®éšå±¤ã‚’è§£æ”¾ (Unlock Next Tier)';
      unlockBtn.addEventListener('click', ()=> buyNextTierOnce());
      unlockLine.appendChild(unlockBtn);
      genCard.appendChild(unlockLine);
      shop.appendChild(genCard);

      // Mines area
      const mineCard = document.createElement('div'); mineCard.className='card';
      const mineUnlocked = skillNodes[SKILL_COUNT-1] && skillNodes[SKILL_COUNT-1].purchased;
      mineCard.innerHTML = `<div><strong>Mines</strong> â€” æ‰€æŒ: <span id="mineCount">${minesCount}</span>${mineUnlocked ? '' : 'ï¼ˆæœ€å¾Œã®ã‚¹ã‚­ãƒ«ã‚’è³¼å…¥ã§è§£æ”¾ï¼‰'}</div>
        <div class="small">Mine ã¯ GDP ã‚’ç”Ÿæˆã—ã¾ã™ã€‚GDP ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼åŠ¹ç‡ã‚’å¼·åŒ–ã§ãã¾ã™ã€‚</div>`;
      shop.appendChild(mineCard);
      if (mineUnlocked){
        const mineControls = document.createElement('div'); mineControls.className='card';
        mineControls.innerHTML = `<div class="small">æ¬¡ã® Mine ã®ã‚³ã‚¹ãƒˆ: ${mineCostIP(1).toString()} IP</div>
          <button id="buyMine1" class="btn btn-small">Buy Ã—1</button> <button id="buyMine5" class="btn btn-small">Buy Ã—5</button>
          <div style="margin-top:6px" class="small">GDP ã‚’ä½¿ã£ã¦ã‚¸ã‚§ãƒåŠ¹ç‡ã‚’æ’ä¹…çš„ã«ä¸Šã’ã‚‹: <button id="spendGDP" class="btn btn-small">Spend 100 GDP (+2% eff)</button></div>`;
        shop.appendChild(mineControls);
        setTimeout(()=>{ const b1 = document.getElementById('buyMine1'); const b5 = document.getElementById('buyMine5'); const sp = document.getElementById('spendGDP');
          if (b1) b1.addEventListener('click', ()=> buyMineWithIP(1));
          if (b5) b5.addEventListener('click', ()=> buyMineWithIP(5));
          if (sp) sp.addEventListener('click', ()=> spendGDPBoostAll(0.02, 100));
        },0);
      }

      // Challenges UI (9)
      const chCard = document.createElement('div'); chCard.className='card col';
      chCard.innerHTML = `<div><strong>Infinity ãƒãƒ£ãƒ¬ãƒ³ã‚¸</strong></div><div class="small">æœ€å¤§ 9 å€‹ã€‚é”æˆæ•°ã«å¿œã˜ã¦ IP å€ç‡ãŒå¢—åŠ ã—ã¾ã™ï¼ˆ1å€‹ã§Ã—2ã€9å€‹ã§Ã—18ï¼‰ã€‚</div>`;
      infinityChallenges.forEach(c => {
        const line = document.createElement('div');
        line.style.display='flex'; line.style.gap='8px'; line.style.alignItems='center'; line.style.marginTop='6px';
        const status = c.completed ? 'é”æˆæ¸ˆ' : (c.active ? 'é€²è¡Œä¸­' : 'æœªé–‹å§‹');
        line.innerHTML = `<div style="flex:1"><strong>${c.name}</strong> â€” ${c.desc}</div><div class="small">${status}</div>`;
        const btnStart = document.createElement('button'); btnStart.className='btn btn-small'; btnStart.textContent = c.active ? 'åœæ­¢' : 'é–‹å§‹';
        btnStart.addEventListener('click', ()=> { if (c.active) stopChallenge(c.id); else startChallenge(c.id); });
        const btnComp = document.createElement('button'); btnComp.className='btn btn-small'; btnComp.textContent='Complete (manual)';
        btnComp.addEventListener('click', ()=> completeChallengeManual(c.id));
        line.appendChild(btnStart); line.appendChild(btnComp);
        chCard.appendChild(line);
      });
      shop.appendChild(chCard);
    }

    // Debug helpers
    (function() {
      const params = window.location.search;
      const match = params.match(/\?=(.+)/);
      if (!match) return;
      const command = match[1];
      console.log("DEBUG MODE:", command);
      const [key, value] = command.split(":");
      switch (key) {
        case "prestige":
          money = BigNum.fromNumber(1e21);
          updateUI_throttled(true);
          alert("ãƒ‡ãƒãƒƒã‚°: ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸æ¡ä»¶ã‚’æº€ãŸã—ã¾ã—ãŸ");
          break;
        case "infinity":
          money = BigNum.fromMantExp(1.8,308);
          updateUI_throttled(true);
          alert("ãƒ‡ãƒãƒƒã‚°: ç„¡é™æ¡ä»¶ã‚’æº€ãŸã—ã¾ã—ãŸ");
          break;
        case "ascend":
          upgrades.forEach(u => u.level = getLevelCap(u));
          updateUI_throttled(true);
          alert("ãƒ‡ãƒãƒƒã‚°: å…¨ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã‚’Lvä¸Šé™ã«ã—ã¾ã—ãŸ");
          break;
        case "money":
          money = BigNum.fromNumber(Number(value) || 1e10);
          updateUI_throttled(true);
          alert("ãƒ‡ãƒãƒƒã‚°: æ‰€æŒé‡‘ã‚’ " + value + " ã«è¨­å®šã—ã¾ã—ãŸ");
          break;
        case "addIP":
          infinityPoints.addInPlace(BigNum.fromNumber(Number(value) || 1));
          updateUI_throttled(true);
          alert("ãƒ‡ãƒãƒƒã‚°: IP ã‚’è¿½åŠ ã—ã¾ã—ãŸ");
          break;
        case "addG1":
          generators[0].count += Number(value) || 1;
          updateUI_throttled(true);
          alert("ãƒ‡ãƒãƒƒã‚°: G1 ã‚’è¿½åŠ ã—ã¾ã—ãŸ");
          break;
        case "completeAllChallenges":
          infinityChallenges.forEach(c=>c.completed=true);
          saveChallenges();
          updateUI_throttled(true);
          alert("ãƒ‡ãƒãƒƒã‚°: å…¨ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã‚’é”æˆã«ã—ã¾ã—ãŸ");
          break;
        case "reset":
          if (confirm("æœ¬å½“ã«å…¨ã¦ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ")){
            fullReset();
            alert("ãƒ‡ãƒãƒƒã‚°: ã‚»ãƒ¼ãƒ–ã‚’å®Œå…¨ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ");
          }
          break;
        default:
          alert("ä¸æ˜ãªãƒ‡ãƒãƒƒã‚°ã‚³ãƒãƒ³ãƒ‰: " + command);
      }
    })();

    // Tabs
    const tabGen = document.getElementById('tabGen');
    const tabInf = document.getElementById('tabInf');
    const upgradeEl = document.getElementById('upgradeContainer');
    const shopEl = document.getElementById('prestigeShop');
    function showTab(t){
      if (t === 'gen'){
        tabGen.classList.add('active');
        tabInf.classList.remove('active');
        upgradeEl.style.display = '';
        shopEl.style.display = 'none';
      } else {
        tabGen.classList.remove('active');
        tabInf.classList.add('active');
        upgradeEl.style.display = 'none';
        shopEl.style.display = '';
      }
    }
    tabGen.addEventListener('click', ()=> showTab('gen'));
    tabInf.addEventListener('click', ()=> showTab('inf'));
    showTab('gen');

    // apply loaded challenge/skill states
    applySkillEffects();
    window.__genEffMultiplier = (window.__genEffBaseFromSkills || 1) * (1 + minesCount * 0.05);

  } catch(err){
    showError(err && err.message ? err.message : String(err));
  }
})();
</script>
</body>
</html>
