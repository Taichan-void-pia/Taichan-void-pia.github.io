<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>Idle â€” Prestige & Infinity (All features)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui, "Segoe UI", Roboto, Helvetica, Arial; background:#071018;color:#fff;margin:0;padding:16px}
  h1{color:#7bf3a8;margin:0 0 8px 0}
  .errorBanner{background:#5b1010;color:#fff;padding:8px;border-radius:6px;margin-bottom:10px;display:none}
  .stats{background:rgba(255,255,255,0.03);padding:10px;border-radius:8px;margin-bottom:10px}
  #money{font-weight:700;color:#7bf3a8}
  #upgradeContainer{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:10px}
  .upgrade{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px}
  .meter{height:14px;background:rgba(255,255,255,0.04);border-radius:7px;overflow:hidden;margin:6px 0}
  .fill{height:100%;background:linear-gradient(90deg,#7bf3a8,#39d092);width:100%;transform-origin:left;will-change:transform}
  .btn{padding:6px;border-radius:6px;border:0;cursor:pointer}
  .btn-primary{background:#7bf3a8;color:#003628}
  .btn-small{background:rgba(255,255,255,0.03);color:#cfe8da;padding:4px 6px}
  .panel{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;margin-top:8px;display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .small{font-size:0.85em;color:#cfe8da}
  .speedControls{display:flex;gap:8px;align-items:center}
  .invisible{display:none}
  .shop{margin-top:10px;display:flex;gap:8px;flex-wrap:wrap}
  .shop .card{background:rgba(255,255,255,0.03);padding:8px;border-radius:6px}
  .col{display:flex;flex-direction:column;gap:6px}
  .skillsGrid{display:grid;grid-template-columns:repeat(10,1fr);gap:6px;margin-top:8px}
  .skillBtn{background:rgba(255,255,255,0.02);padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);cursor:pointer;font-size:0.8em;white-space:pre-line}
  .skillBtn.purchased{box-shadow:0 0 8px rgba(123,243,168,0.6);border-color:#7bf3a8}
  .tabs{display:flex;gap:8px;margin:8px 0}
  .tabBtn{padding:6px 10px;border-radius:6px;background:rgba(255,255,255,0.03);cursor:pointer}
  .tabBtn.active{background:#7bf3a8;color:#003628}
  .cardRow{display:flex;gap:8px;flex-wrap:wrap}
</style>
</head>
<body>
  <div id="error" class="errorBanner"></div>

  <h1>ğŸ’° æ”¾ç½®ã‚²ãƒ¼ãƒ  â€” Prestige & Infinity (All features)</h1>

  <div class="stats">
    æ‰€æŒé‡‘ï¼š<span id="money">0</span>ã€€
    ç§’ã‚ãŸã‚Šï¼š<span id="rate">0</span>
    <div class="small" id="formula">(è¨ˆç®—å¼)</div>
    <div style="margin-top:8px">
      ç„¡é™ãƒ¡ãƒ¼ã‚¿ãƒ¼ï¼š
      <div class="meter" style="display:inline-block;width:40%;margin-left:8px;vertical-align:middle">
        <div id="inftyFill" class="fill" style="transform:scaleX(0)"></div>
      </div>
      <span id="inftyPct" class="small" style="margin-left:8px">0%</span>
      <button id="gainInfinityBtn" class="btn btn-primary invisible" style="margin-left:10px">ç„¡é™ã‚’å¾—ã‚‹</button>
      <span class="small" style="margin-left:8px">ç„¡é™ãƒã‚¤ãƒ³ãƒˆ(IP): <span id="inftyPoints">0</span></span>
    </div>
  </div>

  <div class="panel">
    <div style="display:flex;gap:8px;align-items:center">
      <button id="prestigeBtn" class="btn btn-primary invisible">âœ¨ ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸</button>
      <button id="resetBtn" class="btn btn-small">ãƒªã‚»ãƒƒãƒˆï¼ˆå®Œå…¨ï¼‰</button>
      <label class="small" style="margin-left:8px">Auto-buy:
        <select id="autoQty">
          <option value="1">Ã—1</option><option value="10">Ã—10</option><option value="100">Ã—100</option><option value="max">Ã—Max</option>
        </select>
        <input id="autoToggle" type="checkbox" style="margin-left:6px" />ï¼ˆãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸1å›å¾Œã«æœ‰åŠ¹ï¼‰
      </label>
    </div>

    <div class="speedControls small" style="margin-left:auto">
      å€é€Ÿï¼š
      <select id="speedSelect">
        <option value="1">1Ã—</option>
        <option value="2">2Ã—</option>
        <option value="3">3Ã—</option>
      </select>
      <button id="speedDec" class="btn btn-small">-</button>
      <button id="speedInc" class="btn btn-small">+</button>
      <button id="pauseBtn" class="btn btn-small">ä¸€æ™‚åœæ­¢</button>
    </div>
  </div>

  <div class="tabs" role="tablist">
    <button id="tabGen" class="tabBtn active">Generation</button>
    <button id="tabInf" class="tabBtn">Infinity</button>
  </div>

  <div id="upgradeContainer"></div>

  <div id="prestigeShop" class="shop" style="display:none"></div>

<script>
(function(){
  function showError(msg){
    const el = document.getElementById('error');
    el.style.display = 'block';
    el.textContent = 'ã‚¨ãƒ©ãƒ¼: ' + msg;
    console.error(msg);
  }

  try {
    // -------- BigNum ----------
    class BigNum {
      constructor(m=0,e=0){ this.m=m; this.e=e; this._normalize(); }
      static zero(){ return new BigNum(0,0); }
      static fromNumber(n){
        if (!isFinite(n) || n === 0) return BigNum.zero();
        const sign = n<0?-1:1;
        n = Math.abs(n);
        const exp = Math.floor(Math.log10(n));
        const mant = n / Math.pow(10, exp);
        return new BigNum(sign * mant, exp);
      }
      static fromObject(o){ if (!o || typeof o.m!=='number' || typeof o.e!=='number') return BigNum.zero(); return new BigNum(o.m, o.e); }
      static fromMantExp(m,e){ return new BigNum(m,e); }
      clone(){ return new BigNum(this.m, this.e); }
      _normalize(){
        if (!isFinite(this.m) || !isFinite(this.e) || this.m === 0){
          if (this.m === 0){ this.e = 0; this.m = 0; return; }
          if (!isFinite(this.m)) this.m = this.m > 0 ? 9.9999999999999 : -9.9999999999999;
        }
        if (this.m === 0){ this.e = 0; return; }
        let sign = this.m < 0 ? -1 : 1;
        let mabs = Math.abs(this.m);
        if (mabs === 0){ this.m = 0; this.e = 0; return; }
        const shift = Math.floor(Math.log10(mabs));
        if (isFinite(shift) && shift !== 0){ mabs = mabs / Math.pow(10, shift); this.e = this.e + shift; }
        if (mabs >= 10){ mabs = mabs / 10; this.e = this.e + 1; }
        this.m = sign * mabs;
      }
      toObject(){ return {m:this.m, e:this.e}; }
      toNumberSafe(){ if (!isFinite(this.m) || !isFinite(this.e)) return NaN; if (this.e > 15 || this.e < -15) return this.m>0?Infinity:-Infinity; return this.m * Math.pow(10, this.e); }
      toString(){ if (this.m === 0) return "0"; if (this.e <=12 && this.e >= -6){ const v=this.toNumberSafe(); if (isFinite(v)) return v.toLocaleString(undefined,{maximumFractionDigits:2}); } return this.m.toFixed(3) + "e" + this.e; }
      addInPlace(other){ if (typeof other === 'number') other = BigNum.fromNumber(other); if (!(other instanceof BigNum)) return; if (this.m === 0){ this.m = other.m; this.e = other.e; return; } if (other.m === 0) return; const diff = this.e - other.e; if (Math.abs(diff) > 15){ if (diff > 0) return; else { this.m = other.m; this.e = other.e; return; } } if (diff >= 0){ const scaled = other.m * Math.pow(10, -diff); this.m = this.m + scaled; } else { const scaled = this.m * Math.pow(10, diff); this.m = other.m + scaled; this.e = other.e; } this._normalize(); }
      subInPlace(other){ if (typeof other === 'number') other = BigNum.fromNumber(other); if (!(other instanceof BigNum)) return; other = new BigNum(-other.m, other.e); this.addInPlace(other); }
      mulInPlace(other){ if (typeof other === 'number'){ if (!isFinite(other) || other === 0){ this.m = 0; this.e = 0; return; } other = BigNum.fromNumber(other); } if (!(other instanceof BigNum)) return; if (this.m === 0 || other.m === 0){ this.m = 0; this.e = 0; return; } this.m = this.m * other.m; this.e = this.e + other.e; this._normalize(); }
      mulByNumber(n){ if (typeof n !== 'number') return; if (!isFinite(n) || n === 0){ this.m = 0; this.e = 0; return; } this.m = this.m * n; this._normalize(); }
      addNumber(n){ this.addInPlace(BigNum.fromNumber(n)); }
      gteNumber(n){ if (typeof n !== 'number') n = Number(n); if (!isFinite(n)) return false; if (n === 0) return this.m >= 0; const bn = BigNum.fromNumber(n); return this.gteBig(bn); }
      gteBig(b){ if (!(b instanceof BigNum)) b = BigNum.fromObject(b); if (this.m === 0 && b.m === 0) return true; if (this.e !== b.e) return this.e > b.e; return Math.abs(this.m) >= Math.abs(b.m); }
      subNumber(n){ this.subInPlace(BigNum.fromNumber(n)); }
    }

    // --------------- constants & templates ---------------
    const INF_TARGET = BigNum.fromMantExp(1.8, 308); // 1.8e308
    const PROGRESS_CAP = 1e9;
    let costBaseMultVar = 1.15;

    const upgradesTemplate = [
      { name:"åå…¥ã‚¢ãƒƒãƒ—", baseRate:0.9, rate:0.9, mult:0, speedMult:1.18, baseCost:12, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"åŠ¹ç‡ã‚¢ãƒƒãƒ—", baseRate:0.6, rate:0.6, mult:0, speedMult:1.16, baseCost:40, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"è‡ªå‹•è²©å£²æ©Ÿ", baseRate:0.45, rate:0.45, mult:0, speedMult:1.14, baseCost:120, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"éŠ€è¡ŒæŠ•è³‡", baseRate:0.3, rate:0.3, mult:0, speedMult:1.12, baseCost:520, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"AIç”Ÿæˆå·¥å ´", baseRate:0.18, rate:0.18, mult:0, speedMult:1.10, baseCost:2200, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°", baseRate:0.14, rate:0.14, mult:0, speedMult:1.09, baseCost:12000, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"ç ”ç©¶æ‰€", baseRate:0.11, rate:0.11, mult:0, speedMult:1.085, baseCost:60000, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"æƒ‘æ˜Ÿé–‹ç™º", baseRate:0.08, rate:0.08, mult:0, speedMult:1.07, baseCost:250000, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"é‡å­ã‚µãƒ¼ãƒãƒ¼", baseRate:0.05, rate:0.05, mult:0, speedMult:1.055, baseCost:1200000, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
      { name:"æ¬¡å…ƒã‚³ã‚¢", baseRate:0.02, rate:0.02, mult:0, speedMult:1.04, baseCost:6000000, level:0, progress:0, prestigeLevel:{mult:0,rate:0,cost:0}, ascendCount:0, purchasePenalty:0 },
    ];
    function cloneTemplate(){ return JSON.parse(JSON.stringify(upgradesTemplate)); }

    // --------------- state ---------------
    let money = BigNum.zero();
    let baseIncome = BigNum.fromNumber(1);
    let upgrades = cloneTemplate();
    let prestigePoints = 0; // integer points user can spend in shop (Generation)
    let prestigeCount = 0;
    let prestigeMult = BigNum.fromNumber(1);
    let lastPrestigeScore = BigNum.zero();
    // infinityPoints now BigNum (IP)
    let infinityPoints = BigNum.zero();

    // global prestige bonuses (purchased with prestigePoints)
    const baseGlobalPrestige = { mAdd: 0, rMul: 1.0, costMul: 1.0 };
    const globalPrestige = Object.assign({}, baseGlobalPrestige);

    // --- Infinity / Generators (Step4) ---
    let generatorPoints = 0; // GP (number, small float)
    let generators = new Array(10).fill(0).map(()=>({count:0,progress:0}));
    let genBaseCost = [1,3,10,30,100,300,1000,3000,10000,30000];
    let genCostScale = 1.9; // increased cost scale per request

    // GP penalty parameters (penalty grows with generatorPoints; can be reduced by skill nodes)
    let gpPenaltyBase = 0.02; // base penalty factor
    let gpPenaltyReductionFromSkills = 0; // 0..1

    // Mines (new)
    let minesCount = 0;
    const minesBaseCost = BigNum.fromNumber(5); // IP costs (BigNum)
    const minesCostScale = 2.0;

    // GoldenParticle (GDP) produced by mines
    let goldenParticle = 0; // number (can be large but manageable as number)

    // Infinity Challenges (9)
    const INF_CHALLENGE_STORAGE = 'idle_inf_challenges_v2';
    const infinityChallenges = [];
    for (let i=1;i<=9;i++){
      infinityChallenges.push({
        id: 'C'+i,
        name: 'Challenge ' + i,
        desc: 'ãƒãƒ£ãƒ¬ãƒ³ã‚¸ ' + i + ' ã®åˆ¶ç´„ (ä¾‹)ã€‚å ±é…¬: IP å€ç‡è²¢çŒ®',
        reqIP: 0,
        active: false,
        completed: false,
        reward: { type:'ipLinearAdd', value:2 } // each completed contributes factor "2" (linear stacking)
      });
    }

    // SkillNodes (50) purchasable with IP. sequential purchase enforced.
    const SKILL_STORAGE_KEY = 'idle_skill_nodes_v2';
    // generate 50 nodes with variety of effects; some nodes reduce gp penalty
    const skillNodes = new Array(50).fill(0).map((_,i)=>{
      const idx = i+1;
      // pattern of effects
      const cycle = [
        {type:'mAdd', value:0.01},
        {type:'rMul', value:1.02},
        {type:'costMul', value:0.95},
        {type:'baseIncome', value:1.05},
        {type:'genEff', value:1.10},
        {type:'gpPenaltyReduction', value:0.002} // reduces GP penalty slightly
      ];
      const eff = cycle[i % cycle.length];
      // cost scale: choose exponent so node50 cost ~ 1e33
      // costExponent = (i/50)*33 -> node50 exponent 33 -> 1e33
      const rawLog = (idx/50) * 33;
      const expPart = Math.floor(rawLog);
      const mantPart = Math.pow(10, rawLog - expPart);
      const costBN = BigNum.fromMantExp(mantPart, expPart);
      return {
        id:'S'+idx,
        index: idx,
        name: idx + '. ' + (eff.type==='mAdd'?'å¾®å¢—M': eff.type==='rMul'?'é€Ÿåº¦+': eff.type==='costMul'?'ã‚³ã‚¹ãƒˆæ¸›': eff.type==='baseIncome'?'åŸºç¤åå…¥+': eff.type==='genEff'?'ã‚¸ã‚§ãƒåŠ¹ç‡+':'GPãƒšãƒŠãƒ«ãƒ†ã‚£è»½æ¸›'),
        effect: eff,
        purchased: false,
        cost: costBN // BigNum
      };
    });

    // helpers
    function fmtSmall(n){
      if (typeof n === 'number'){
        if (!isFinite(n)) return "Infinity";
        if (Math.abs(n) >= 1e15) return n.toExponential(2);
        if (Math.abs(n) >= 1e9) return (n/1e9).toFixed(2) + "B";
        if (Math.abs(n) >= 1e6) return (n/1e6).toFixed(2) + "M";
        return Math.floor(n).toLocaleString();
      }
      if (n instanceof BigNum) return n.toString();
      return String(n);
    }

    function bigNumLog10(bn){
      if (!(bn instanceof BigNum)) bn = BigNum.fromObject(bn);
      if (bn.m === 0) return -Infinity;
      return bn.e + Math.log10(Math.abs(bn.m));
    }

    // sanitize upgrades
    function sanitizeUpgrades(list){
      for (let i=0;i<list.length;i++){
        const u = list[i];
        if (!u || typeof u !== 'object'){ list[i] = JSON.parse(JSON.stringify(upgradesTemplate[i])); continue; }
        if (typeof u.mult !== 'number') u.mult = 0;
        if (typeof u.rate !== 'number') u.rate = u.baseRate || upgradesTemplate[i].baseRate;
        if (typeof u.baseCost !== 'number') u.baseCost = upgradesTemplate[i].baseCost;
        if (typeof u.level !== 'number') u.level = 0;
        if (typeof u.progress !== 'number') u.progress = 0;
        if (!u.prestigeLevel || typeof u.prestigeLevel !== 'object') u.prestigeLevel = {mult:0,rate:0,cost:0};
        if (typeof u.ascendCount !== 'number') u.ascendCount = 0;
        if (typeof u.purchasePenalty !== 'number') u.purchasePenalty = 0;
        u._rateBN = u._rateBN ? BigNum.fromObject(u._rateBN) : BigNum.fromNumber(u.rate);
        u._multBN = u._multBN ? BigNum.fromObject(u._multBN) : BigNum.fromNumber(u.mult);
        u._baseCostBN = u._baseCostBN ? BigNum.fromObject(u._baseCostBN) : BigNum.fromNumber(u.baseCost);
      }
    }

    function getLevelCap(u){ return 100 + (u.ascendCount || 0) * 10; }

    function getUpgradeCostBig(u, extraLevelOffset=0){
      const level = (u.level + extraLevelOffset);
      const factor = Math.pow(costBaseMultVar, Math.max(0, level));
      const c = u._baseCostBN.clone();
      c.mulByNumber(factor);
      const penalty = 1 + (u.purchasePenalty || 0);
      c.mulByNumber(penalty);
      c.mulByNumber(globalPrestige.costMul);
      return c;
    }

    // Skill load/save/apply
    function loadSkillNodes(){
      try {
        const raw = localStorage.getItem(SKILL_STORAGE_KEY);
        if (!raw) return;
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr) || arr.length !== skillNodes.length) return;
        for (let i=0;i<skillNodes.length;i++){ skillNodes[i].purchased = !!arr[i].purchased; }
      } catch(e){ console.warn('loadSkillNodes fail', e); }
    }
    function saveSkillNodes(){
      try {
        const arr = skillNodes.map(s => ({id:s.id, purchased: !!s.purchased}));
        localStorage.setItem(SKILL_STORAGE_KEY, JSON.stringify(arr));
      } catch(e){ console.warn('saveSkillNodes fail', e); }
    }
    function applySkillEffects(){
      // reset
      Object.assign(globalPrestige, JSON.parse(JSON.stringify(baseGlobalPrestige)));
      baseIncome = BigNum.fromNumber(1);
      let genEffMultiplier = 1.0;
      gpPenaltyReductionFromSkills = 0;
      for (let i=0;i<skillNodes.length;i++){
        const s = skillNodes[i];
        if (!s.purchased) continue;
        const eff = s.effect;
        switch(eff.type){
          case 'mAdd': globalPrestige.mAdd += eff.value; break;
          case 'rMul': globalPrestige.rMul *= eff.value; break;
          case 'costMul': globalPrestige.costMul *= eff.value; break;
          case 'baseIncome': baseIncome.mulByNumber(eff.value); break;
          case 'genEff': genEffMultiplier *= eff.value; break;
          case 'gpPenaltyReduction': gpPenaltyReductionFromSkills += eff.value; break;
        }
      }
      // mines affect gen eff
      window.__genEffBaseFromSkills = genEffMultiplier;
      window.__genEffMultiplier = genEffMultiplier * (1 + minesCount * 0.05) * (1 + goldenParticle * 0.001);
      // reduce gp penalty base by reduction sum (cap to 90% reduction)
      gpPenaltyBase = Math.max(0, 0.02 * Math.max(0.1, 1 - gpPenaltyReductionFromSkills));
    }

    // UI init
    const upgradeUI = [];
    function initUI(){
      const container = document.getElementById('upgradeContainer');
      container.innerHTML = '';
      upgrades.forEach((u,i)=>{
        const div = document.createElement('div');
        div.className = 'upgrade';
        const rateStr = (u._rateBN && u._rateBN.toNumberSafe && isFinite(u._rateBN.toNumberSafe())) ? u._rateBN.toNumberSafe().toFixed(2) : u._rateBN.toString();
        div.innerHTML = `
          <div style="display:flex;justify-content:space-between"><strong>${i+1}. ${u.name}</strong><div class="small">Lv <span id="lvl${i}">0</span>/<span id="cap${i}">100</span></div></div>
          <div class="small">æ˜‡å¤©å›æ•°: <span id="asc${i}">0</span></div>
          <div class="small">æ°¸ç¶š Lv(m/r/c): <span id="pLv${i}">0</span>/<span id="pLvR${i}">0</span>/<span id="pLvC${i}">0</span></div>
          <div class="small">ä¹—æ•°åˆè¨ˆ: <span id="mult${i}">+0.000</span></div>
          <div class="small">ãƒ¡ãƒ¼ã‚¿ãƒ¼é€Ÿåº¦: <span id="rate${i}">${rateStr}</span>/s</div>
          <div class="meter"><div id="fill${i}" class="fill" style="transform:scaleX(0)"></div></div>
          <div style="display:flex;gap:6px;flex-wrap:wrap;justify-content:center">
            <button id="buy1_${i}" class="btn btn-primary">è³¼å…¥ï¼ˆ<span id="cost${i}">0</span>ï¼‰</button>
            <button id="buy10_${i}" class="btn btn-small">Ã—10</button>
            <button id="buy100_${i}" class="btn btn-small">Ã—100</button>
            <button id="buyMax_${i}" class="btn btn-small">Ã—Max</button>
            <button id="asc_${i}" class="btn btn-small invisible">æ˜‡å¤©</button>
          </div>
        `;
        container.appendChild(div);
        upgradeUI[i] = {
          fillEl: document.getElementById('fill'+i),
          lvlEl: document.getElementById('lvl'+i),
          capEl: document.getElementById('cap'+i),
          costEl: document.getElementById('cost'+i),
          multEl: document.getElementById('mult'+i),
          rateEl: document.getElementById('rate'+i),
          ascEl: document.getElementById('asc'+i),
          pLvEl: document.getElementById('pLv'+i),
          pLvREl: document.getElementById('pLvR'+i),
          pLvCEl: document.getElementById('pLvC'+i),
          btn1: document.getElementById('buy1_'+i),
          btn10: document.getElementById('buy10_'+i),
          btn100: document.getElementById('buy100_'+i),
          btnMax: document.getElementById('buyMax_'+i),
          btnAsc: document.getElementById('asc_'+i),
        };
        upgradeUI[i].btn1.addEventListener('click', ()=> buyUpgrade(i,1,false));
        upgradeUI[i].btn10.addEventListener('click', ()=> buyUpgrade(i,10,false));
        upgradeUI[i].btn100.addEventListener('click', ()=> buyUpgrade(i,100,false));
        upgradeUI[i].btnMax.addEventListener('click', ()=> buyUpgrade(i,'max',false));
        upgradeUI[i].btnAsc.addEventListener('click', ()=> tryAscend(i));
      });

      prevProgress = new Array(upgrades.length).fill(0);
      currProgress = new Array(upgrades.length).fill(0);
      for (let i=0;i<upgrades.length;i++){ prevProgress[i] = upgrades[i].progress || 0; currProgress[i] = upgrades[i].progress || 0; }

      renderPrestigeShop();
    }

    // prestige boost (exponential smooth)
    function prestigeBoostMultiplier(){
      const pp = Number(prestigePoints) || 0;
      if (pp <= 0) return 1;
      const exponent = 0.01 * Math.sqrt(pp);
      const safeExp = Math.min(exponent, 700);
      const mult = Math.exp(safeExp);
      if (!isFinite(mult)) return Number.MAX_VALUE;
      return mult;
    }

    // Infinity progress percent (log scale)
    function computeInfinityProgressPercent(bn){
      if (!(bn instanceof BigNum)) bn = BigNum.fromObject(bn);
      if (bn.m === 0) return 0;
      const logVal = bigNumLog10(bn);
      const logStart = 0; // start at 10^0
      const logTarget = bigNumLog10(INF_TARGET);
      if (!isFinite(logVal)) return 0;
      if (logVal < logStart) return 0;
      if (logVal >= logTarget) return 100;
      const pct = (logVal - logStart) / (logTarget - logStart) * 100;
      return Math.max(0, Math.min(100, pct));
    }

    // throttled UI update
    let lastUI = 0;
    function updateUI_throttled(force){
      const now = performance.now();
      if (!force && now - lastUI < 100) return;
      lastUI = now;

      // compute total multiplier using BigNum fully
      let totalMultBN = BigNum.fromNumber(1);
      for (let i=0;i<upgrades.length;i++){
        const u = upgrades[i];
        const pMult = 0.02 * ((u.prestigeLevel && u.prestigeLevel.mult) || 0); // small additive
        const asc = 0.05 * (u.ascendCount || 0);
        const factorBN = BigNum.fromNumber(1);
        factorBN.addInPlace(u._multBN);
        factorBN.addNumber(pMult + asc + (globalPrestige.mAdd || 0));
        totalMultBN.mulInPlace(factorBN);
      }

      // baseIncome * totalMult
      const rateBN = baseIncome.clone();
      rateBN.mulInPlace(totalMultBN);

      // apply prestige boost as final exponential multiplier
      const prestigeMultNum = prestigeBoostMultiplier();
      rateBN.mulByNumber(prestigeMultNum);

      // apply challenge finalMult rewards (none here except ip multiplier effect handled elsewhere)

      // For display
      const rateDisplayNum = rateBN.toNumberSafe();
      const rateEl = document.getElementById('rate');
      if (isFinite(rateDisplayNum) && Math.abs(rateBN.e) <= 16){
        rateEl.textContent = rateDisplayNum.toFixed(2);
      } else {
        rateEl.textContent = rateBN.toString();
      }

      // formula (human readable)
      let formulaParts = upgrades.map(u=>{
        const n = (u._multBN && u._multBN.toNumberSafe && isFinite(u._multBN.toNumberSafe())) ? u._multBN.toNumberSafe() : 0;
        const part = 1 + n + 0.02 * ((u.prestigeLevel&&u.prestigeLevel.mult)||0) + 0.05 * (u.ascendCount||0) + (globalPrestige.mAdd || 0);
        return '(1+' + part.toFixed(3) + ')';
      });
      document.getElementById('formula').textContent = 'åå…¥ = baseIncome Ã— ' + formulaParts.join(' Ã— ') + ' Ã— Prestige(exp)  ï¼ˆå€é€Ÿ: ' + speedMultiplier.toFixed(0) + (paused ? ' åœæ­¢ä¸­' : '') + 'ï¼‰';

      for (let i=0;i<upgrades.length;i++){
        const u = upgrades[i], ui = upgradeUI[i];
        if (!ui) continue;
        ui.lvlEl.textContent = u.level;
        ui.capEl.textContent = getLevelCap(u);
        ui.costEl.textContent = getUpgradeCostBig(u,0).toString();
        const multNum = u._multBN.toNumberSafe();
        ui.multEl.textContent = '+' + (isFinite(multNum) ? multNum.toFixed(3) : u._multBN.toString());
        const rateClone = u._rateBN.clone();
        rateClone.mulByNumber(globalPrestige.rMul || 1);
        const rateNum = rateClone.toNumberSafe();
        ui.rateEl.textContent = isFinite(rateNum) ? rateNum.toFixed(2) : rateClone.toString();
        ui.ascEl.textContent = u.ascendCount || 0;
        ui.pLvEl.textContent = (u.prestigeLevel && u.prestigeLevel.mult) || 0;
        ui.pLvREl.textContent = (u.prestigeLevel && u.prestigeLevel.rate) || 0;
        ui.pLvCEl.textContent = (u.prestigeLevel && u.prestigeLevel.cost) || 0;

        if (u.level >= getLevelCap(u)) ui.btnAsc.classList.remove('invisible'); else ui.btnAsc.classList.add('invisible');
        const canBuy = u.level < getLevelCap(u);
        ui.btn1.disabled = !canBuy;
        ui.btn10.disabled = !canBuy;
        ui.btn100.disabled = !canBuy;
        ui.btnMax.disabled = !canBuy;
      }

      const prestigeBtn = document.getElementById('prestigeBtn');
      let canPrestige = false;
      if (money.gteNumber(1e20)) {
        if (prestigeCount === 0) canPrestige = true;
        else {
          if (isMoneyGreaterThan(money, lastPrestigeScore)) canPrestige = true;
        }
      }
      if (canPrestige) prestigeBtn.classList.remove('invisible'); else prestigeBtn.classList.add('invisible');

      const inftyFill = document.getElementById('inftyFill');
      const inftyBtn = document.getElementById('gainInfinityBtn');
      const pct = computeInfinityProgressPercent(money);
      inftyFill.style.transform = 'scaleX(' + (pct/100) + ')';
      const pctEl = document.getElementById('inftyPct');
      if (pctEl) pctEl.textContent = pct.toFixed(6) + '%';
      if (money.gteBig(INF_TARGET) || allChallengesCompleted()) inftyBtn.classList.remove('invisible'); else inftyBtn.classList.add('invisible');

      document.getElementById('inftyPoints').textContent = infinityPoints.toString();

      renderPrestigeShop();
    }

    function isMoneyGreaterThan(a,b){
      if (!(a instanceof BigNum)) a = BigNum.fromObject(a);
      if (!(b instanceof BigNum)) b = BigNum.fromObject(b);
      if (a.e !== b.e) return a.e > b.e;
      return Math.abs(a.m) > Math.abs(b.m);
    }

    function costToBuyBig(u, n){
      if (n <= 0) return BigNum.zero();
      const remaining = Math.max(0, getLevelCap(u) - u.level);
      const want = Math.min(n, remaining);
      let total = BigNum.zero();
      for (let k=0;k<want;k++){
        const piece = getUpgradeCostBig(u, k);
        total.addInPlace(piece);
      }
      return total;
    }

    function getMultiplierIncrementBig(u){
      const base = 0.005 * Math.pow(1 + u.level, 0.38);
      const genFactor = 1 + ((window.__genEffBaseFromSkills || 1) - 1) + (generatorPoints || 0) * 0.1;
      return BigNum.fromNumber(Math.min(base * genFactor, 1e12));
    }

    // buy upgrade (Generation)
    function buyUpgrade(idx, qty, silent){
      const u = upgrades[idx];
      if (u.level >= getLevelCap(u)){ if (!silent) alert('ã“ã®ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã¯æœ€å¤§Lvã§ã™ï¼ˆ' + getLevelCap(u) + 'ï¼‰'); return; }
      if (qty === 'max'){
        const remaining = getLevelCap(u) - u.level;
        let lo = 0, hi = 1;
        while (hi <= remaining && money.gteBig(costToBuyBig(u,hi))) hi *= 2;
        hi = Math.min(hi, remaining);
        while (lo + 1 < hi){
          const mid = Math.floor((lo + hi)/2);
          if (money.gteBig(costToBuyBig(u, mid))) lo = mid;
          else hi = mid;
        }
        if (lo > 0) doPurchase(u, idx, lo);
        else if (!silent) alert('ãŠé‡‘ãŒè¶³ã‚Šã¾ã›ã‚“');
        return;
      }
      const n = Number(qty) || 1;
      const allowed = Math.min(n, getLevelCap(u) - u.level);
      if (allowed <= 0){ if (!silent) alert('ã“ã‚Œä»¥ä¸Šè³¼å…¥ã§ãã¾ã›ã‚“ï¼ˆLvä¸Šé™ï¼‰'); return; }
      const costBN = costToBuyBig(u, allowed);
      if (money.gteBig(costBN)) doPurchase(u, idx, allowed);
      else if (!silent) alert('ãŠé‡‘ãŒè¶³ã‚Šã¾ã›ã‚“');
    }

    function doPurchase(u, idx, n){
      const costBN = costToBuyBig(u, n);
      money.subInPlace(costBN);
      const exponent = n * 0.12;
      const multiplier = Math.pow(Math.max(1, u.speedMult), exponent);
      u._rateBN.mulByNumber(multiplier);
      if (u._rateBN.e > 300) u._rateBN = BigNum.fromNumber(1e300);
      u.level += n;
      saveGame();
      updateUI_throttled(true);
    }

    function tryAscend(i){
      const u = upgrades[i];
      if (u.level < getLevelCap(u)){ alert('Lvä¸Šé™ã«åˆ°é”ã—ã¦ã‹ã‚‰æ˜‡å¤©å¯èƒ½ã§ã™ï¼ˆç¾åœ¨ Lv ' + u.level + ' / ' + getLevelCap(u) + 'ï¼‰'); return; }
      if (!confirm(u.name + ' ã‚’æ˜‡å¤©ã—ã¾ã™ã‹ï¼Ÿ LvãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã€æ°¸ç¶šãƒœãƒ¼ãƒŠã‚¹ãŒä»˜ä¸ã•ã‚Œã¾ã™ã€‚')) return;
      u.ascendCount = (u.ascendCount || 0) + 1;
      u.purchasePenalty = (u.purchasePenalty || 0) + 0.25;
      u.level = 0;
      u.progress = 0;
      u._rateBN = BigNum.fromNumber(u.baseRate || 1);
      u._multBN = BigNum.zero();
      saveGame();
      updateUI_throttled(true);
      alert(u.name + ' ã‚’æ˜‡å¤©ã—ã¾ã—ãŸï¼ˆæ˜‡å¤©å›æ•°: ' + u.ascendCount + 'ï¼‰\nè©²å½“ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã®ã‚³ã‚¹ãƒˆãŒæ°¸ç¶šã§ +25% ã•ã‚Œã¾ã—ãŸã€‚');
    }

    // PRESTIGE logic (Generation)
    function prestigePointsForScore(bn){
      if (!(bn instanceof BigNum)) bn = BigNum.fromObject(bn);
      if (bn.m === 0) return 0;
      const mantLog = Math.log10(Math.abs(bn.m));
      const log10val = bn.e + mantLog;
      const diff = log10val - 20;
      if (!isFinite(diff) || diff < 0) return 0;
      const points = Math.floor(diff) + 1;
      return points;
    }

    function doPrestige(force){
      let can = false;
      if (money.gteNumber(1e20)){
        if (prestigeCount === 0) can = true;
        else if (isMoneyGreaterThan(money, lastPrestigeScore)) can = true;
      }
      if (!force && !can){ alert('ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã›ã‚“'); return; }
      if (!force && !confirm('ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’å®Ÿè¡Œã—ã¾ã™ã‹ï¼Ÿï¼ˆå…¨ã¦ãƒªã‚»ãƒƒãƒˆã€ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ãƒã‚¤ãƒ³ãƒˆä»˜ä¸ã€‚ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ã¯å‰å›ã‚ˆã‚Šé«˜ã„ã‚¹ã‚³ã‚¢ã§ã®ã¿å†åº¦å¯èƒ½ï¼‰')) return;

      const pts = prestigePointsForScore(money);
      if (pts <= 0 && !force){ alert('ã‚¹ã‚³ã‚¢ãŒä¸ååˆ†ã§ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ãƒã‚¤ãƒ³ãƒˆã¯å¾—ã‚‰ã‚Œã¾ã›ã‚“'); return; }

      prestigePoints += pts;
      prestigeCount += 1;
      lastPrestigeScore = money.clone();

      money = BigNum.zero();
      baseIncome = BigNum.fromNumber(1);
      upgrades = cloneTemplate();
      sanitizeUpgrades(upgrades);
      saveGame();
      initUI();
      updateUI_throttled(true);
      alert('ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸å®Œäº†: prestigePoints +' + pts + '\nç¾åœ¨ã®ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ãƒã‚¤ãƒ³ãƒˆ: ' + prestigePoints);
    }

    // helper: count completed challenges
    function countCompletedChallenges(){
      return infinityChallenges.filter(c=>c.completed).length;
    }
    function allChallengesCompleted(){ return infinityChallenges.every(c=>c.completed); }

    // gain Infinity (IP) with multi-IP via distance when exceeding INF_TARGET & challenge multiplier
    function gainInfinity(){
      // allow when money >= INF_TARGET OR if Infinity Break (all challenges) allow exceeding
      if (!(money.gteBig(INF_TARGET) || allChallengesCompleted())){
        alert('ã¾ã ç„¡é™ã«åˆ°é”ã—ã¦ã„ã¾ã›ã‚“');
        return;
      }
      // compute base IP: at least 1
      let extra = 0;
      try {
        const logMoney = bigNumLog10(money);
        const logTarget = bigNumLog10(INF_TARGET);
        if (isFinite(logMoney) && isFinite(logTarget)){
          extra = Math.floor(Math.max(0, logMoney - logTarget));
        }
      } catch(e){ extra = 0; }
      // base award = 1 + extra
      let baseAward = 1 + extra;
      // challenge linear multiplier: per spec 1 complete -> 2x, 9 complete -> 18x
      const completed = countCompletedChallenges();
      const challengeMult = completed === 0 ? 1 : 2 * completed;
      // final award:
      let award = baseAward * challengeMult;

      if (!confirm(`ç„¡é™ã‚’å–å¾—ã—ã¾ã™ã‹ï¼Ÿ\nIP ã‚’ ${award} ä»˜ä¸ã—ã¦ Generation ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚`)) return;

      // award IP
      infinityPoints.addInPlace(BigNum.fromNumber(award));

      // Reset Generation but KEEP skillNodes purchased, IP, mines etc.
      money = BigNum.zero();
      baseIncome = BigNum.fromNumber(1);
      upgrades = cloneTemplate();
      sanitizeUpgrades(upgrades);
      prestigePoints = 0;
      prestigeCount = 0;
      prestigeMult = BigNum.fromNumber(1);
      lastPrestigeScore = BigNum.zero();

      costBaseMultVar = 1.15;
      Object.assign(globalPrestige, JSON.parse(JSON.stringify(baseGlobalPrestige)));

      speedMultiplier = 1.0;
      paused = false;
      displayMoneyNum = 0;
      prevProgress = new Array(upgrades.length).fill(0);
      currProgress = new Array(upgrades.length).fill(0);

      // keep skill nodes, mines, generators (generators remain - per design)
      applySkillEffects();
      saveGame();
      updateUI_throttled(true);
      alert('ç„¡é™ã‚’å¾—ã¾ã—ãŸï¼ IP +' + award);
    }

    // RESET (full)
    function fullReset(){
      try { localStorage.removeItem('idle_all_big_save'); } catch(e){}
      try { localStorage.removeItem(SKILL_STORAGE_KEY); } catch(e){}
      try { localStorage.removeItem(INF_CHALLENGE_STORAGE); } catch(e){}
      money = BigNum.zero();
      baseIncome = BigNum.fromNumber(1);
      upgrades = cloneTemplate();
      sanitizeUpgrades(upgrades);
      prestigePoints = 0;
      prestigeCount = 0;
      prestigeMult = BigNum.fromNumber(1);
      lastPrestigeScore = BigNum.zero();
      infinityPoints = BigNum.zero();
      costBaseMultVar = 1.15;
      Object.assign(globalPrestige, JSON.parse(JSON.stringify(baseGlobalPrestige)));
      generatorPoints = 0;
      generators = new Array(10).fill(0).map(()=>({count:0,progress:0}));
      minesCount = 0;
      goldenParticle = 0;
      infinityChallenges.forEach(c => { c.active = false; c.completed = false; });
      speedMultiplier = 1.0;
      paused = false;
      displayMoneyNum = 0;
      prevProgress = new Array(upgrades.length).fill(0);
      currProgress = new Array(upgrades.length).fill(0);
      skillNodes.forEach(s => s.purchased = false);
      saveSkillNodes();
      saveGame();
      initUI();
      updateUI_throttled(true);
    }

    // Save / Load (save infinityPoints as object)
    function saveGame(){
      try {
        const save = {
          money: money.toObject(),
          baseIncome: baseIncome.toObject(),
          upgrades: upgrades.map(u => ({
            name:u.name, baseRate:u.baseRate,
            rateBN: u._rateBN.toObject(), multBN: u._multBN.toObject(), baseCostBN: u._baseCostBN.toObject(),
            baseCost: u.baseCost, level: u.level, progress: u.progress, prestigeLevel: u.prestigeLevel || {mult:0,rate:0,cost:0}, ascendCount: u.ascendCount || 0, purchasePenalty: u.purchasePenalty || 0
          })),
          prestigePoints,
          prestigeCount,
          prestigeMult: prestigeMult.toObject(),
          lastPrestigeScore: lastPrestigeScore.toObject(),
          infinityPoints: infinityPoints.toObject(),
          globalPrestige,
          costBaseMultVar,
          speedMultiplier,
          paused,
          generatorPoints,
          generators,
          minesCount,
          goldenParticle,
          skillNodes: skillNodes.map(s => ({id:s.id,purchased:s.purchased})),
          challenges: infinityChallenges.map(c => ({id:c.id, active:c.active, completed:c.completed}))
        };
        localStorage.setItem('idle_all_big_save', JSON.stringify(save));
        saveSkillNodes();
        saveChallenges();
      } catch(e){ console.warn('save fail', e); try{ localStorage.removeItem('idle_all_big_save'); }catch(e){} }
    }

    function loadGame(){
      try {
        const raw = localStorage.getItem('idle_all_big_save');
        if (!raw) return;
        let data;
        try { data = JSON.parse(raw); } catch(parseErr){ console.warn('save parse failed, clearing', parseErr); localStorage.removeItem('idle_all_big_save'); return; }
        if (!data || typeof data !== 'object') return;

        if (data.money && typeof data.money.m === 'number') money = BigNum.fromObject(data.money);
        if (data.baseIncome && typeof data.baseIncome.m === 'number') baseIncome = BigNum.fromObject(data.baseIncome);

        if (Array.isArray(data.upgrades) && data.upgrades.length === upgradesTemplate.length){
          upgrades = data.upgrades.map((s,i) => {
            const t = JSON.parse(JSON.stringify(upgradesTemplate[i]));
            const merged = Object.assign(t, s);
            merged._rateBN = (s && s.rateBN) ? BigNum.fromObject(s.rateBN) : BigNum.fromNumber(merged.rate || merged.baseRate || 1);
            merged._multBN = (s && s.multBN) ? BigNum.fromObject(s.multBN) : BigNum.fromNumber(merged.mult || 0);
            merged._baseCostBN = (s && s.baseCostBN) ? BigNum.fromObject(s.baseCostBN) : BigNum.fromNumber(merged.baseCost || upgradesTemplate[i].baseCost);
            merged.level = Number.isFinite(+merged.level) ? Math.max(0, Math.floor(+merged.level)) : 0;
            merged.progress = Number.isFinite(+merged.progress) ? +merged.progress : 0;
            merged.prestigeLevel = merged.prestigeLevel || {mult:0,rate:0,cost:0};
            merged.ascendCount = Number.isFinite(+merged.ascendCount) ? +merged.ascendCount : 0;
            merged.purchasePenalty = Number.isFinite(+merged.purchasePenalty) ? +merged.purchasePenalty : 0;
            return merged;
          });
        }

        if (typeof data.prestigePoints === 'number') prestigePoints = data.prestigePoints;
        if (typeof data.prestigeCount === 'number') prestigeCount = data.prestigeCount;
        if (data.prestigeMult && typeof data.prestigeMult.m === 'number') prestigeMult = BigNum.fromObject(data.prestigeMult);
        if (data.lastPrestigeScore && typeof data.lastPrestigeScore.m === 'number') lastPrestigeScore = BigNum.fromObject(data.lastPrestigeScore);

        if (data.infinityPoints && typeof data.infinityPoints.m === 'number') infinityPoints = BigNum.fromObject(data.infinityPoints);

        if (data.globalPrestige && typeof data.globalPrestige === 'object') Object.assign(globalPrestige, data.globalPrestige);
        if (typeof data.costBaseMultVar === 'number') costBaseMultVar = data.costBaseMultVar;
        if (typeof data.speedMultiplier === 'number') speedMultiplier = Math.max(1, Math.min(3, Math.round(data.speedMultiplier)));
        if (typeof data.paused === 'boolean') paused = !!data.paused;

        if (typeof data.generatorPoints === 'number') generatorPoints = data.generatorPoints;
        if (Array.isArray(data.generators) && data.generators.length === 10){
          generators = data.generators.map(g => ({
            count: Number.isFinite(+g.count) ? Math.max(0, Math.floor(+g.count)) : 0,
            progress: Number.isFinite(+g.progress) ? +g.progress : 0
          }));
        }

        if (typeof data.minesCount === 'number') minesCount = data.minesCount;
        if (typeof data.goldenParticle === 'number') goldenParticle = data.goldenParticle;

        if (Array.isArray(data.skillNodes)){
          data.skillNodes.forEach(sn => {
            const idx = skillNodes.findIndex(s=>s.id===sn.id);
            if (idx>=0) skillNodes[idx].purchased = !!sn.purchased;
          });
        }
        if (Array.isArray(data.challenges)){
          data.challenges.forEach(sc => {
            const c = infinityChallenges.find(x => x.id === sc.id);
            if (c){ c.active = !!sc.active; c.completed = !!sc.completed; }
          });
        }

        sanitizeUpgrades(upgrades);
      } catch(e){ console.warn('loadGame failed, clearing save', e); try{ localStorage.removeItem('idle_all_big_save'); }catch(e){} }
    }

    // simulation + render
    sanitizeUpgrades(upgrades);
    loadGame();
    loadSkillNodes();
    applySkillEffects();
    sanitizeUpgrades(upgrades);
    initUI();
    updateUI_throttled(true);

    // simulation params
    const FIXED_DT = 0.05;
    let accumulator = 0;
    let lastTime = performance.now();

    // speedMultiplier and paused declared before usage
    let speedMultiplier = 1.0; // 1..3
    let paused = false;

    function simulateGenerators(dt){
      // GP generation from G1
      const g1count = generators[0].count || 0;
      // gp generation penalty: gpPenaltyBase * generatorPoints reduces effective GP production
      const gpPenalty = gpPenaltyBase * Math.max(0, generatorPoints);
      const gpPenaltyFactor = 1 / (1 + gpPenalty);
      const g1PerSecPer = 0.001 * (window.__genEffMultiplier || 1) * gpPenaltyFactor;
      const gpGain = g1count * g1PerSecPer * dt;
      if (gpGain > 0) generatorPoints += gpGain;

      // generate lower-tier via higher-tier
      for (let tier = 1; tier < generators.length; tier++){
        const g = generators[tier];
        if (!g || g.count <= 0) continue;
        const perSec = 0.1 * g.count * (window.__genEffMultiplier || 1) * gpPenaltyFactor;
        g.progress += perSec * dt;
        if (g.progress >= 1){
          const inc = Math.floor(g.progress);
          g.progress -= inc;
          generators[tier-1].count += inc;
        }
      }
      // Mines generate GDP
      if (minesCount > 0){
        const gdpPerMine = 0.01; // per second per mine
        goldenParticle += minesCount * gdpPerMine * dt;
        // update gen eff multiplier to reflect GDP
        window.__genEffMultiplier = (window.__genEffBaseFromSkills || 1) * (1 + minesCount * 0.05) * (1 + goldenParticle * 0.001);
      }
    }

    function simulateStep(dt){
      const s = speedMultiplier;
      for (let i=0;i<upgrades.length;i++){
        const u = upgrades[i];
        prevProgress[i] = currProgress[i];
        let progRate = NaN;
        try { progRate = (u._rateBN && typeof u._rateBN.toNumberSafe === 'function') ? u._rateBN.toNumberSafe() : NaN; } catch(e){ progRate = NaN; }
        if (!isFinite(progRate) || progRate <= 0) progRate = (u.baseRate || 0.01);
        progRate *= (globalPrestige.rMul || 1);
        let incProg = progRate * dt * 100 * s;
        if (!isFinite(incProg)) incProg = 0;
        currProgress[i] += incProg;
        if (currProgress[i] > PROGRESS_CAP) currProgress[i] = PROGRESS_CAP;
        if (currProgress[i] >= 100){
          let completed = Math.floor(currProgress[i] / 100);
          if (completed > 1000000) completed = 1000000;
          currProgress[i] -= completed * 100;
          const incBaseBN = getMultiplierIncrementBig(u);
          incBaseBN.mulByNumber(completed);
          u._multBN.addInPlace(incBaseBN);
          if (u._multBN.e > 300) u._multBN = BigNum.fromNumber(1e300);
        }
        u.progress = currProgress[i];
      }

      // compute total multiplier (BigNum)
      let totalMultBN = BigNum.fromNumber(1);
      for (let i=0;i<upgrades.length;i++){
        const u = upgrades[i];
        const pMult = 0.02 * ((u.prestigeLevel && u.prestigeLevel.mult) || 0);
        const asc = 0.05 * (u.ascendCount || 0);
        const factorBN = BigNum.fromNumber(1);
        factorBN.addInPlace(u._multBN);
        factorBN.addNumber(pMult + asc + (globalPrestige.mAdd || 0));
        totalMultBN.mulInPlace(factorBN);
      }

      const addBN = baseIncome.clone();
      addBN.mulInPlace(totalMultBN);

      const prestigeMultNum = prestigeBoostMultiplier();
      addBN.mulByNumber(prestigeMultNum);

      // apply challenge rewards that affect final income (if any)
      infinityChallenges.forEach(c => {
        if (!c.completed) return;
        if (c.reward.type === 'finalMult' && c.reward.value) addBN.mulByNumber(c.reward.value);
      });

      // apply softcap gently (kept internal; tuning removed from UI)
      const softCapStartLog = 150;
      const softCapStrength = 0.01;
      const softMult = (() => {
        const logVal = bigNumLog10(money);
        if (!isFinite(logVal)) return 1;
        if (logVal <= softCapStartLog) return 1;
        const excess = logVal - softCapStartLog;
        const reduction = Math.pow(10, -softCapStrength * excess);
        if (!isFinite(reduction) || reduction <= 0) return 0;
        return Math.max(0, Math.min(1, reduction));
      })();
      addBN.mulByNumber(softMult);

      addBN.mulByNumber(dt * s);

      money.addInPlace(addBN);

      // clamp money to INF_TARGET unless Infinity Break active (all challenges completed)
      if (!allChallengesCompleted() && money.gteBig(INF_TARGET)) {
        money = INF_TARGET.clone();
      }

      simulateGenerators(dt);
    }

    function render(){
      const now = performance.now();
      let frameDelta = (now - lastTime) / 1000;
      if (!isFinite(frameDelta) || frameDelta <= 0) frameDelta = 0;
      lastTime = now;
      if (frameDelta > 0.5) frameDelta = 0.5;
      accumulator += frameDelta;
      if (accumulator > 0.5) accumulator = 0.5;

      if (!paused){
        while (accumulator >= FIXED_DT){
          simulateStep(FIXED_DT);
          accumulator -= FIXED_DT;
        }
      } else {
        accumulator = 0;
        for (let i=0;i<upgrades.length;i++) prevProgress[i] = currProgress[i];
      }

      const alpha = FIXED_DT === 0 ? 0 : (accumulator / FIXED_DT);

      // money display
      if (money.m === 0){
        displayMoneyNum += (0 - displayMoneyNum) * 0.12;
        document.getElementById('money').textContent = fmtSmall(displayMoneyNum);
      } else if (money.e <= 12){
        const v = money.toNumberSafe();
        if (isFinite(v)){
          displayMoneyNum += (v - displayMoneyNum) * 0.12;
          document.getElementById('money').textContent = fmtSmall(displayMoneyNum);
        } else {
          document.getElementById('money').textContent = money.toString();
        }
      } else {
        document.getElementById('money').textContent = money.toString();
      }

      for (let i=0;i<upgrades.length;i++){
        const interp = prevProgress[i] + (currProgress[i] - prevProgress[i]) * alpha;
        const w = Math.min(Math.max(interp, 0), 100);
        const el = upgradeUI[i] && upgradeUI[i].fillEl;
        if (el){
          const scale = Math.max(0, Math.min(1, w / 100));
          el.style.transform = 'scaleX(' + scale + ')';
        }
      }

      updateUI_throttled();
      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

    // wiring
    const prestigeBtn = document.getElementById('prestigeBtn');
    prestigeBtn.addEventListener('click', ()=> doPrestige(false));

    const inftyBtn = document.getElementById('gainInfinityBtn');
    if (inftyBtn) inftyBtn.addEventListener('click', gainInfinity);
    window.addEventListener('beforeunload', ()=> saveGame());

    const resetBtn = document.getElementById('resetBtn');
    resetBtn.addEventListener('click', ()=> {
      if (!confirm('æœ¬å½“ã«ã‚»ãƒ¼ãƒ–ã‚’å‰Šé™¤ã—ã¦ã‚²ãƒ¼ãƒ ã‚’å®Œå…¨ã«åˆæœŸåŒ–ã—ã¾ã™ã‹ï¼Ÿï¼ˆå…ƒã«æˆ»ã›ã¾ã›ã‚“ï¼‰')) return;
      fullReset();
      alert('ã‚²ãƒ¼ãƒ ã‚’å®Œå…¨ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚ã‚»ãƒ¼ãƒ–ã‚‚å‰Šé™¤ã•ã‚Œã¦ã„ã¾ã™ã€‚');
    });

    // auto-buy
    setInterval(function(){
      try {
        const autoOn = document.getElementById('autoToggle').checked && prestigeCount >= 1;
        if (!autoOn) return;
        const qty = document.getElementById('autoQty').value;
        const order = upgrades.map((u,i)=>({i,c:getUpgradeCostBig(u)})).sort((a,b)=>{
          if (a.c.e !== b.c.e) return a.c.e - b.c.e;
          return Math.abs(a.c.m) - Math.abs(b.c.m);
        });
        for (let k=0;k<order.length;k++){
          const entry = order[k];
          if (upgrades[entry.i].level >= getLevelCap(upgrades[entry.i])) continue;
          if (money.gteBig(entry.c)){
            buyUpgrade(entry.i, qty, true);
            break;
          }
        }
      } catch(e){ console.warn('auto-buy error', e); }
    }, 900);

    // speed UI
    const speedSelect = document.getElementById('speedSelect');
    const speedInc = document.getElementById('speedInc');
    const speedDec = document.getElementById('speedDec');
    const pauseBtn = document.getElementById('pauseBtn');
    function clampSpeed(v){ return Math.max(1, Math.min(3, Math.round(v))); }
    function updateSpeedUI(force){
      speedMultiplier = clampSpeed(speedMultiplier);
      speedSelect.value = String(speedMultiplier);
      pauseBtn.textContent = paused ? 'å†é–‹' : 'ä¸€æ™‚åœæ­¢';
      if (force) updateUI_throttled(true);
      saveGame();
    }
    speedSelect.addEventListener('change', ()=> { speedMultiplier = clampSpeed(Number(speedSelect.value)); updateSpeedUI(true); });
    speedInc.addEventListener('click', ()=> { speedMultiplier = clampSpeed(speedMultiplier + 1); updateSpeedUI(true); });
    speedDec.addEventListener('click', ()=> { speedMultiplier = clampSpeed(speedMultiplier - 1); updateSpeedUI(true); });
    pauseBtn.addEventListener('click', ()=> { paused = !paused; if (paused) accumulator = 0; updateSpeedUI(true); });
    window.addEventListener('keydown', (e) => {
      if (e.key === '['){ speedMultiplier = clampSpeed(speedMultiplier - 1); updateSpeedUI(true); e.preventDefault(); }
      else if (e.key === ']'){ speedMultiplier = clampSpeed(speedMultiplier + 1); updateSpeedUI(true); e.preventDefault(); }
      else if (e.code === 'Space'){ paused = !paused; if (paused) accumulator = 0; updateSpeedUI(true); e.preventDefault(); }
    });

    updateSpeedUI(true);

    // ===== Infinity (Prestige) UI & logic =====
    function genCostForPurchase(tier, qty){
      const base = genBaseCost[tier];
      let total = 0;
      let cur = generators[tier].count || 0;
      for (let k=0;k<qty;k++){
        total += Math.ceil(base * Math.pow(genCostScale, cur + k));
      }
      return total;
    }
    function buyGenerator(tier, qty){
      qty = Number(qty) || 1;
      if (qty <= 0) return;
      const cost = genCostForPurchase(tier, qty);
      // infinityPoints is BigNum - compare as number (cost uses integer)
      const ipNum = infinityPoints.toNumberSafe();
      if (!isFinite(ipNum) || ipNum < cost){ alert('IPãŒè¶³ã‚Šã¾ã›ã‚“'); return; }
      // subtract cost (convert to BigNum)
      infinityPoints.subInPlace(BigNum.fromNumber(cost));
      generators[tier].count += qty;
      saveGame();
      updateUI_throttled(true);
      alert(`G${tier+1} ã‚’ ${qty} å€‹è³¼å…¥ã—ã¾ã—ãŸï¼ˆIP -${cost}ï¼‰`);
    }

    // Mines
    function mineCost(qty){
      let total = BigNum.zero();
      let cur = minesCount;
      for (let i=0;i<qty;i++){
        const piece = BigNum.fromNumber(Math.ceil(Math.pow(minesCostScale, cur + i) * 5));
        total.addInPlace(piece);
      }
      return total;
    }
    function buyMine(qty){
      qty = Number(qty) || 1;
      if (qty <= 0) return;
      const cost = mineCost(qty);
      if (!infinityPoints.gteBig(cost)){ alert('IPãŒè¶³ã‚Šã¾ã›ã‚“'); return; }
      // subtract
      // subtract BigNum
      const newIP = infinityPoints.clone(); newIP.subInPlace(cost); infinityPoints = newIP;
      minesCount += qty;
      // update gen eff multiplier
      window.__genEffMultiplier = (window.__genEffBaseFromSkills || 1) * (1 + minesCount * 0.05) * (1 + goldenParticle * 0.001);
      saveGame();
      updateUI_throttled(true);
      alert(`Mine ã‚’ ${qty} å€‹è³¼å…¥ã—ã¾ã—ãŸï¼ˆIP -${cost.toString()}ï¼‰`);
    }

    // Challenges
    function loadChallenges(){
      try {
        const raw = localStorage.getItem(INF_CHALLENGE_STORAGE);
        if (!raw) return;
        const arr = JSON.parse(raw);
        if (!Array.isArray(arr)) return;
        arr.forEach(a => {
          const c = infinityChallenges.find(x => x.id === a.id);
          if (c){ c.active = !!a.active; c.completed = !!a.completed; }
        });
      } catch(e){ console.warn('loadChallenges fail', e); }
    }
    function saveChallenges(){
      try {
        localStorage.setItem(INF_CHALLENGE_STORAGE, JSON.stringify(infinityChallenges.map(c => ({id:c.id, active:c.active, completed:c.completed}))));
      } catch(e){ console.warn('saveChallenges fail', e); }
    }
    function startChallenge(id){
      // only one active at a time
      if (infinityChallenges.some(c=>c.active)) { alert('æ—¢ã«ãƒãƒ£ãƒ¬ãƒ³ã‚¸ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ã™ã€‚ã¾ãšã¯è§£é™¤ã—ã¦ãã ã•ã„ã€‚'); return; }
      const c = infinityChallenges.find(x=>x.id===id);
      if (!c) return;
      if (!confirm(`${c.name} ã‚’é–‹å§‹ã—ã¾ã™ã‹ï¼Ÿ\nåŠ¹æœ: ${c.desc}\né–‹å§‹ã™ã‚‹ã¨GenerationãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã™ã€‚`)) return;
      c.active = true;
      // reset generation-like but keep IP/mines/skill nodes
      money = BigNum.zero();
      baseIncome = BigNum.fromNumber(1);
      upgrades = cloneTemplate();
      sanitizeUpgrades(upgrades);
      prestigePoints = 0;
      prestigeCount = 0;
      lastPrestigeScore = BigNum.zero();
      applySkillEffects();
      window.__genEffMultiplier = (window.__genEffBaseFromSkills || 1) * (1 + minesCount * 0.05) * (1 + goldenParticle * 0.001);
      saveChallenges();
      saveGame();
      initUI();
      updateUI_throttled(true);
      alert('ãƒãƒ£ãƒ¬ãƒ³ã‚¸é–‹å§‹: ' + c.name);
    }
    function stopChallenge(id){
      const c = infinityChallenges.find(x=>x.id===id);
      if (!c) return;
      if (!c.active) return;
      if (!confirm(`${c.name} ã‚’çµ‚äº†ã—ã¾ã™ã‹ï¼Ÿï¼ˆãƒãƒ£ãƒ¬ãƒ³ã‚¸çŠ¶æ…‹ã‚’è§£é™¤ã—ã¾ã™ï¼‰`)) return;
      c.active = false;
      saveChallenges();
      saveGame();
      updateUI_throttled(true);
      alert('ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã‚’è§£é™¤ã—ã¾ã—ãŸ: ' + c.name);
    }
    // mark challenge complete (for testing / UI)
    function completeChallenge(id){
      const c = infinityChallenges.find(x=>x.id===id);
      if (!c) return;
      c.active = false;
      c.completed = true;
      saveChallenges();
      saveGame();
      updateUI_throttled(true);
      alert('ãƒãƒ£ãƒ¬ãƒ³ã‚¸é”æˆ: ' + c.name);
    }

    // Skill UI (placed in prestigeShop)
    function initSkillUI(shop){
      const prev = shop.querySelector('#skillArea');
      if (prev) prev.remove();
      const skillCard = document.createElement('div');
      skillCard.id = 'skillArea';
      skillCard.className = 'card col';
      skillCard.innerHTML = `<div><strong>ç„¡é™ã‚¹ã‚­ãƒ«ãƒ„ãƒªãƒ¼ï¼ˆSkill Nodesï¼‰</strong></div><div class="small">IPã§è³¼å…¥ã—ã¾ã™ã€‚å·¦ã‹ã‚‰é †ã«è³¼å…¥å¯èƒ½ã€‚50ç•ªã§Minesè§£æ”¾ã€‚</div>`;
      const grid = document.createElement('div');
      grid.className = 'skillsGrid';
      skillNodes.forEach((s, idx) => {
        const btn = document.createElement('button');
        btn.className = 'skillBtn' + (s.purchased ? ' purchased' : '');
        btn.id = 'skillBtn_' + idx;
        btn.textContent = s.name + '\nCost: ' + s.cost.toString();
        btn.disabled = !!s.purchased || !canBuySkillIndex(idx);
        btn.addEventListener('click', ()=>{
          const detail = `ID:${s.id}\n${s.name}\nEffect: ${s.effect.type} Ã— ${s.effect.value}\nCost: ${s.cost.toString()}\nPurchased: ${s.purchased ? 'Yes' : 'No'}`;
          if (s.purchased){
            alert(detail);
            return;
          }
          if (!canBuySkillIndex(idx)){ alert('å…ˆã«å‰ã®ãƒãƒ¼ãƒ‰ã‚’è³¼å…¥ã—ã¦ãã ã•ã„'); return; }
          if (!confirm(detail + '\n\nè³¼å…¥ã—ã¾ã™ã‹ï¼Ÿï¼ˆIP ã‚’æ¶ˆè²»ï¼‰')) return;
          // compare infinityPoints BigNum with cost BigNum
          if (!infinityPoints.gteBig(s.cost)){ alert('IPãŒè¶³ã‚Šã¾ã›ã‚“'); return; }
          // subtract
          const newIP = infinityPoints.clone(); newIP.subInPlace(s.cost); infinityPoints = newIP;
          s.purchased = true;
          saveSkillNodes();
          applySkillEffects();
          saveGame();
          updateUI_throttled(true);
          initSkillUI(shop);
          alert('è³¼å…¥ã—ã¾ã—ãŸ: ' + s.name);
        });
        grid.appendChild(btn);
      });
      skillCard.appendChild(grid);
      shop.appendChild(skillCard);
    }

    // helper: can buy skill at index? sequential purchase
    function canBuySkillIndex(idx){
      if (idx === 0) return true;
      // allow purchase only if previous is purchased
      return !!skillNodes[idx-1].purchased;
    }

    // renderPrestigeShop (clears and rebuilds) - placed in Infinity tab
    function renderPrestigeShop(){
      const shop = document.getElementById('prestigeShop');
      if (!shop) return;
      shop.innerHTML = '';

      // skill area
      initSkillUI(shop);

      // prestige info (Generation-related but placed here per tab)
      const info = document.createElement('div'); info.className='card';
      info.innerHTML = `<div><strong>ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸ãƒã‚¤ãƒ³ãƒˆ: ${prestigePoints}</strong></div><div class="small">ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸å›æ•°: ${prestigeCount}</div><div class="small">IP: ${infinityPoints.toString()}</div>`;
      shop.appendChild(info);

      // Generators
      const genContainer = document.createElement('div'); genContainer.className='card col';
      genContainer.innerHTML = `<div><strong>Generators (G1ã€œG10) â€” IPã§è³¼å…¥</strong></div><div class="small">G1ã¯GPã‚’ç”Ÿæˆã€‚G2..G10ã¯ä¸‹ä½ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚’å¢—ã‚„ã—ã¾ã™ã€‚</div>`;
      for (let t=0;t<generators.length;t++){
        const tier = t;
        const g = generators[tier];
        const base = genBaseCost[tier] || (genBaseCost[genBaseCost.length-1] * Math.pow(10, tier - genBaseCost.length + 1));
        const nextCost = Math.ceil(base * Math.pow(genCostScale, (g.count||0)));
        const line = document.createElement('div'); line.style.display='flex'; line.style.gap='8px'; line.style.alignItems='center';
        line.innerHTML = `<div style="flex:1"><strong>G${tier+1}</strong> â€” æ‰€æŒ: <span id="gcount${tier}">${g.count}</span></div><div class="small">æ¬¡: ${nextCost} IP</div>`;
        const buyBtn = document.createElement('button'); buyBtn.className='btn btn-small'; buyBtn.textContent='Buy Ã—1';
        buyBtn.addEventListener('click', ()=> buyGenerator(tier, 1));
        const buy5 = document.createElement('button'); buy5.className='btn btn-small'; buy5.textContent='Buy Ã—5';
        buy5.addEventListener('click', ()=> buyGenerator(tier, 5));
        line.appendChild(buyBtn); line.appendChild(buy5);
        genContainer.appendChild(line);
      }
      shop.appendChild(genContainer);

      // Mines UI (unlocked by skill node 50)
      const mineCard = document.createElement('div'); mineCard.className='card';
      mineCard.innerHTML = `<div><strong>Mines</strong> â€” æ‰€æŒ: <span id="mineCount">${minesCount}</span></div>
        <div class="small">Mine ã¯ GoldenParticle (GDP) ã‚’ç”Ÿæˆã—ã€GDP ã¯ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ãƒ¼åŠ¹ç‡ã‚’å‘ä¸Šã•ã›ã¾ã™ã€‚æ¬¡ã®ã‚³ã‚¹ãƒˆ: <span id="mineNextCost">${mineCost(1).toString()}</span> IP</div>
        <div style="margin-top:6px"><button id="buyMine1" class="btn btn-small">Buy Ã—1</button> <button id="buyMine5" class="btn btn-small">Buy Ã—5</button></div>`;
      if (!skillNodes[49].purchased){ // index 49 is node50
        mineCard.innerHTML += `<div class="small">â€» Node 50 ã‚’è³¼å…¥ã™ã‚‹ã¨ Mines ãŒè§£æ”¾ã•ã‚Œã¾ã™</div>`;
        // disable buttons
      } else {
        setTimeout(()=>{
          const b1 = document.getElementById('buyMine1');
          const b5 = document.getElementById('buyMine5');
          if (b1) b1.addEventListener('click', ()=> buyMine(1));
          if (b5) b5.addEventListener('click', ()=> buyMine(5));
        },0);
      }
      shop.appendChild(mineCard);

      // Challenges UI
      const chCard = document.createElement('div'); chCard.className='card col';
      chCard.innerHTML = `<div><strong>Infinity ãƒãƒ£ãƒ¬ãƒ³ã‚¸ï¼ˆæœ€å¤§9ï¼‰</strong></div><div class="small">1ã¤é”æˆã§ IP å€ç‡ï¼ˆç·šå½¢ï¼‰ã« +2 ã®å¯„ä¸ï¼ˆä¾‹: 1 å€‹é”æˆ = 2Ã—ã€9 å€‹ã§ 18Ã—ï¼‰</div>`;
      infinityChallenges.forEach(c => {
        const line = document.createElement('div');
        line.style.display='flex'; line.style.gap='8px'; line.style.alignItems='center'; line.style.marginTop='6px';
        line.innerHTML = `<div style="flex:1"><strong>${c.name}</strong> â€” ${c.desc}</div><div class="small">Req IP: ${c.reqIP}</div>`;
        const btn = document.createElement('button'); btn.className='btn btn-small';
        btn.textContent = c.completed ? 'é”æˆæ¸ˆ' : (c.active ? 'åœæ­¢' : 'é–‹å§‹');
        btn.disabled = c.completed;
        btn.addEventListener('click', ()=> {
          if (c.completed) return;
          if (c.active) stopChallenge(c.id);
          else startChallenge(c.id);
        });
        const hardComplete = document.createElement('button'); hardComplete.className='btn btn-small'; hardComplete.textContent='(å®Œäº†)'; // dev action to mark complete
        hardComplete.addEventListener('click', ()=> {
          if (confirm(`ãƒãƒ£ãƒ¬ãƒ³ã‚¸ ${c.name} ã‚’å¼·åˆ¶çš„ã«é”æˆã«ã—ã¾ã™ã‹ï¼Ÿï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰`)){
            c.completed = true; c.active = false; saveChallenges(); saveGame(); updateUI_throttled(true); alert('é”æˆ: ' + c.name);
          }
        });
        line.appendChild(btn); line.appendChild(hardComplete);
        chCard.appendChild(line);
      });
      shop.appendChild(chCard);
    }

    // Debug support
    (function() {
      const params = window.location.search;
      const match = params.match(/\?=(.+)/);
      if (!match) return;
      const command = match[1];
      console.log("DEBUG MODE:", command);
      const [key, value] = command.split(":");
      switch (key) {
        case "prestige":
          money = BigNum.fromNumber(1e21);
          updateUI_throttled(true);
          alert("ãƒ‡ãƒãƒƒã‚°: ãƒ—ãƒ¬ã‚¹ãƒ†ãƒ¼ã‚¸æ¡ä»¶ã‚’æº€ãŸã—ã¾ã—ãŸ");
          break;
        case "infinity":
          money = BigNum.fromMantExp(1.8,308);
          updateUI_throttled(true);
          alert("ãƒ‡ãƒãƒƒã‚°: ç„¡é™æ¡ä»¶ã‚’æº€ãŸã—ã¾ã—ãŸ");
          break;
        case "ascend":
          upgrades.forEach(u => u.level = getLevelCap(u));
          updateUI_throttled(true);
          alert("ãƒ‡ãƒãƒƒã‚°: å…¨ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰ã‚’Lvä¸Šé™ã«ã—ã¾ã—ãŸ");
          break;
        case "money":
          money = BigNum.fromNumber(Number(value) || 1e10);
          updateUI_throttled(true);
          alert("ãƒ‡ãƒãƒƒã‚°: æ‰€æŒé‡‘ã‚’ " + value + " ã«è¨­å®šã—ã¾ã—ãŸ");
          break;
        case "addIP":
          infinityPoints.addInPlace(BigNum.fromNumber(Number(value) || 1));
          updateUI_throttled(true);
          alert("ãƒ‡ãƒãƒƒã‚°: IP ã‚’è¿½åŠ ã—ã¾ã—ãŸ");
          break;
        case "addG1":
          generators[0].count += Number(value) || 1;
          updateUI_throttled(true);
          alert("ãƒ‡ãƒãƒƒã‚°: G1 ã‚’è¿½åŠ ã—ã¾ã—ãŸ");
          break;
        case "completeAllChallenges":
          infinityChallenges.forEach(c=>c.completed=true);
          saveChallenges();
          updateUI_throttled(true);
          alert("å…¨ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã‚’é”æˆæ¸ˆã¿ã«ã—ã¾ã—ãŸ");
          break;
        case "reset":
          if (confirm("æœ¬å½“ã«å…¨ã¦ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ")){
            fullReset();
            alert("ãƒ‡ãƒãƒƒã‚°: ã‚»ãƒ¼ãƒ–ã‚’å®Œå…¨ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ");
          }
          break;
        default:
          alert("ä¸æ˜ãªãƒ‡ãƒãƒƒã‚°ã‚³ãƒãƒ³ãƒ‰: " + command);
      }
    })();

    // ---------------- Tabs handling ----------------
    const tabGen = document.getElementById('tabGen');
    const tabInf = document.getElementById('tabInf');
    const upgradeEl = document.getElementById('upgradeContainer');
    const shopEl = document.getElementById('prestigeShop');
    function showTab(t){
      if (t === 'gen'){
        tabGen.classList.add('active');
        tabInf.classList.remove('active');
        upgradeEl.style.display = '';
        shopEl.style.display = 'none';
      } else {
        tabGen.classList.remove('active');
        tabInf.classList.add('active');
        upgradeEl.style.display = 'none';
        shopEl.style.display = '';
      }
    }
    tabGen.addEventListener('click', ()=> showTab('gen'));
    tabInf.addEventListener('click', ()=> showTab('inf'));
    // default: Generation
    showTab('gen');

    // ensure challenge/load state applied
    loadChallenges();
    applySkillEffects();
    window.__genEffMultiplier = (window.__genEffBaseFromSkills || 1) * (1 + minesCount * 0.05) * (1 + goldenParticle * 0.001);

  } catch(err){
    showError(err && err.message ? err.message : String(err));
  }
})();
</script>
</body>
</html>
